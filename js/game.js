// Generated by LiveScript 1.2.0
/*!
Author: J.-T.Brinkmann (aka. Brinkie Pie)
last-modified: 2013-11-04
source-file: http://brink.peder.us/Monopony/js/game.ls
all rights reserved, you may not modify or distribute this file or any fily associated with it by J.-T. Brinkmann (Brinkie Pie) without written permission
*/
/*
== StyleGuide (for text visible to the user) ==
you:
	* Always prefer using a player's name instead of "you"!
	 exceptions are:
		* if you are talking to the PERSON who is using Monopony (not a specific player). e.g. in forceDice()
		* if it's a text that get's shown only to the specific player's client (board.msgBox, cards, â€¦)
	* don't surround players' names in quotes
plural:
	* always take care to pluralize unknown amounts of something properly.
	  e.g. board.log "This field costs #{plural field.price 'bit'}."
		so in case of the price being 1, it evaluates to "This field costs 1 bit."
	  note: this is useful for i18n too, because some languages have multiple pluralization forms.
numbers:
	* always use "#{number 123}" when showing numbers in a text. This will format the number depending on the user's locale.
	  e.g. in German one thousand dollar, 23 cents are displayed as "$1.000,23" where as in english it's "$1,000.23"
dates:
	* same as with numbers
	  note: if the client doesn't have Intl support, it will fall back to YYYY-MM-DD because that is the least confusing format
	  (given that both MM/DD/YYYY and DD/MM/YYYY are common)
buttons:
	* the text of buttons should be capitalized in a movie title fashion.
	  e.g. "Roll the Dice"

etc:
	* "The Moon" is to be capialized, because in the context of this game, it is a place's name, not only an astonomical objct
	* write "Return-From-the-Moon card(s)" as such (except when in a button's text, then capitalise "Card" as well)
*/
var Monopony, board, player, forceDice, forceCard, showAllCards, clickBtn, checkUnusedPrototypeAttrs, slice$ = [].slice;
(function(it){
  return it();
})(function(){
  var debugLog, requestAnimationFrame, sleep, clone, setLanguage, language, number, date, strCompare_i, xth, plural, list, capitalize, MicroEvent, isNum, randomNum, throttle, safeToString, icedCoffee, Board, Player, Field, ActionField, UtilityField, BuyableField, StationField, FieldMenu, i$, ref$, len$, deck, j$, len1$, card, k$, to$, i, field, ref1$, key$;
  debugLog = function(){
    var args;
    args = slice$.call(arguments);
    console.log("DEBUG:: " + [].join.call(args) + "\n" + new Error().stack);
    if (board.socket) {
      return board.socket.emit('debugLog');
    }
  };
  (function($span){
    var define, NBSP, ref$, MicroEvent_;
    define = function(property, fn){
      if (this.hasOwnProperty(property)) {
        return console.warn("cannot redefine property", this, property, new TypeError().stack);
      } else if (this[property] !== fn) {
        return Object.defineProperty(this, property, {
          enumerable: false,
          writable: true,
          configurable: true,
          value: fn
        });
      }
    };
    define.call(Object.prototype, 'define', define);
    NBSP = "\xa0";
    if (!String.prototype.strip) {
      String.prototype.define('strip', function(it){
        return $.trim(it);
      });
    }
    if (!Function.prototype.bind) {
      (ref$ = Function.prototype).bind == null && (ref$.bind = function(context){
        var fn;
        fn = this;
        return function(){
          return fn.apply(context, arguments);
        };
      });
    }
    if (!Array.prototype.filter) {
      Array.prototype.define('filter', function(fn){
        return $.grep(this, fn);
      });
    }
    if (!window.requestAnimationFrame) {
      requestAnimationFrame = window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || (function(timeOut){
        return function(callback){
          return window.setTimeout(callback, timeOut);
        };
      }.call(this, 1000 / 60));
    }
    sleep = function(time, callback){
      return setTimeout(callback, time);
    };
    clone = function(obj){
      if ($.isArray(obj)) {
        if (obj.length) {
          return importAll$([], obj);
        } else {
          return [];
        }
      } else {
        return clone$(obj);
      }
    };
    setLanguage = function(lang){
      language = lang;
      if ("Intl" in window) {
        number = new Intl.NumberFormat(lang).format;
        date = new Intl.DateTimeFormat(lang).format;
        strCompare_i = function(str1, str2){
          return 0 === new Intl.Collator(lang, {
            usage: "search",
            sensitivity: "base"
          }).compare(str1, str2);
        };
      } else {
        number = (function(thousandMark, decimalPoint){
          return function(num){
            return (repeatString$('0', 3 - num % 3) + "" + num).replace(/(\d\d\d)/g, thousandMark + "$1").replace(/^[0\.]+/, "");
          };
        }.call(this, ".", "."));
        date = function(date){
          return date.getFullYear() + "-" + date.getMonth() + "-" + date.getDate();
        };
        strCompare_i = function(str1, str2){
          return str1 === str2;
        };
      }
      xth = function(i){
        return i + (i === 1
          ? "st"
          : i === 2
            ? "nd"
            : i === 3 ? "rd" : "th");
      };
      plural = function(num, singular, plural){
        plural == null && (plural = singular + 's');
        if (num === 1) {
          return number(num) + "" + NBSP + singular;
        } else {
          return number(num) + "" + NBSP + plural;
        }
      };
      return list = function(elements){
        if (elements.length > 1) {
          elements[elements.length - 2] += " and" + NBSP + elements.pop();
        }
        return elements.join(", ");
      };
    };
    capitalize = function(str){
      return str.replace(/\b\a/, function(letter){
        return letter.toUpperCase();
      });
    };
    /*
    	gender := (player, strMale, strFemale) ->
    		if player.gender == \female
    			return strFemale
    		else
    			return strMale
    */
    $.fn.visible = function(){
      var el;
      if (this.length === 0) {
        return;
      } else if (this.length > 1) {
        return this.first().visible();
      }
      el = this;
      while (el.length) {
        if (el.css('display') === 'none' || el.css('visibility') === 'hidden' || el.css('opacity') === 0) {
          return false;
        }
        el = el.parent();
      }
    };
    $.fn.hidden = function(){
      return !this.visible();
    };
    $.fn.text_fixed_br = function(text){
      return this.html($span.text(text)).html().replace(/\n/g, "<br>");
    };
    $.fn.input = (function(events){
      return function(eventData, handler){
        var $this, lastValue;
        $this = $(this);
        if (arguments.length > 0) {
          if (typeof eventData === 'function' && handler == null) {
            handler = eventData;
            eventData = void 8;
          }
          lastValue = this.val();
          return this.on(events, function(){
            var $this, val, lastValue;
            $this = $(this);
            val = $this.val();
            if (lastValue !== val) {
              lastValue = val;
              return handler.apply(this, arguments);
            }
          });
        } else {
          return this.trigger(name);
        }
      };
    }.call(this, $span[0].oninput != null ? "propertychange keyup change" : "input"));
    $.easing.easeInQuad = function(p){
      return Math.pow(p, 2);
    };
    $.easing.easeOutQuad = function(p){
      return 1 - Math.pow(1 - p, 2);
    };
    MicroEvent = MicroEvent_ = (function(){
      MicroEvent_.displayName = 'MicroEvent_';
      var prototype = MicroEvent_.prototype, constructor = MicroEvent_;
      prototype.bind = function(e, handler){
        var ref$;
        return ((ref$ = this._events || (this._events = {}))[e] || (ref$[e] = [])).push(handler);
      };
      prototype.unbind = function(e, handler){
        if (e in (this._events || (this._events = {}))) {
          return this._events[e].splice(this._events[e].indexOf(handler), 1);
        }
      };
      prototype.once = function(e, handler){
        var emitter;
        emitter = this;
        handler.once = true;
        return this.bind(e, handler);
      };
      prototype.trigger = function(e){
        var data, oneTimeHandlers, i$, ref$, len$, handler, results$ = [];
        data = slice$.call(arguments, 1);
        if (!(e in this._events)) {
          return;
        }
        oneTimeHandlers = [];
        for (i$ = 0, len$ = (ref$ = this._events[e]).length; i$ < len$; ++i$) {
          handler = ref$[i$];
          handler = this._events[e][i$];
          handler.apply(this, data);
          if (handler.once) {
            oneTimeHandlers = oneTimeHandlers.concat(handler);
          }
        }
        for (i$ = 0, len$ = oneTimeHandlers.length; i$ < len$; ++i$) {
          handler = oneTimeHandlers[i$];
          results$.push(this.unbind(e, handler));
        }
        return results$;
      };
      MicroEvent_.mixin = function(dest){
        return import$(dest.prototype, prototype);
      };
      function MicroEvent_(){}
      return MicroEvent_;
    }());
    isNum = function(it){
      return !isNaN(it);
    };
    randomNum = function(max){
      return Math.floor(Math.random() * max);
    };
    throttle = (function(fnToString){
      return importAll$(function(timeout, fn){
        var throtte;
        throtte = arguments.callee;
        return function(){
          var fnStr, i;
          fnStr = fnToString.apply(fn);
          i = throttle.keys.indexOf(fnStr);
          if (i === -1) {
            i = throttle.keys.length;
            throttle.keys.push(fnStr);
          }
          clearTimeout(throttle.timeouts[i]);
          return throttle.timeouts[i] = setTimeout(fn.bind(this, timeout));
        };
      }, {
        keys: [],
        timeouts: []
      });
    }.call(this, Function.prototype.toString));
    Object.prototype.define('timeoutDeferred', function(time, fn){
      var timeout;
      if (!('always' in this)) {
        throw TypeError("timeoutDeferred can only be called on Deferreds!");
      }
      if (typeof time === 'function') {
        fn = time;
        time = 1000;
      }
      timeout = setTimeout(fn, time);
      this.always(function(){
        return clearTimeout(timeout);
      });
      return this;
    });
    safeToString = (function(fnToString, objToString){
      return function(it){
        var ref$;
        if (typeof it === 'function') {
          return fnToString.apply(it);
        } else if (typeof it === 'object') {
          return objToString.apply(it);
        } else if ((ref$ = typeof it) === 'string' || ref$ === 'number' || ref$ === 'boolean') {
          return it + '';
        }
        return '';
      };
    }.call(this, Function.prototype.toString, Object.prototype.toString));
    Object.prototype.define('isEmptyObject', function(){
      var a;
      for (a in this) {
        return false;
      }
      return true;
    });
    if (!('filter' in Array.prototype)) {
      Array.prototype.define('filter', function(fn, thisArg){
        var res, i, item;
        res = [];
        return [(function(){
          var i$, len$, results$ = [];
          for (i$ = 0, len$ = this.length; i$ < len$; ++i$) {
            i = i$;
            item = this[i$];
            if (fn.call(thisArg, item, i, this)) {
              results$.push(item);
            }
          }
          return results$;
        }.call(this))];
      });
    }
    Array.prototype.define('contains', function(it){
      return this.indexOf(it) !== -1;
    });
    Array.prototype.define('remove', function(it){
      var index;
      index = this.indexOf(it);
      if (index !== -1) {
        return this.splice(index, 1);
      }
    });
    Array.prototype.define('removeItem', function(it){
      return this.remove(it);
    });
    Array.prototype.define('sans', function(it){
      var index;
      index = this.indexOf(it);
      if (index !== -1) {
        return this.slice(0, index).concat(this.slice(index + 1));
      } else {
        return this;
      }
    });
    Array.prototype.define('shuffle', function(){
      var m, i, t;
      m = this.length;
      while (m) {
        i = randomNum(m);
        t = this[--m];
        this[m] = this[i];
        this[i] = t;
      }
      return this;
    });
    Array.prototype.define('random', function(){
      return this[Math.floor(Math.random() * this.length)];
    });
    Array.prototype.define('randomUnused', function(used, attrKey){
      var possibleValues, i$, len$, usedObj;
      possibleValues = importAll$([], this);
      for (i$ = 0, len$ = used.length; i$ < len$; ++i$) {
        usedObj = used[i$];
        possibleValues.removeItem(usedObj[attrKey]);
      }
      if (possibleValues.length === 0) {
        return null;
      } else {
        return possibleValues.random();
      }
    });
    /* e.g.:
    		<- icedCoffee (await) ->
    			for let otherPlayer in board.players
    				if otherPlayer != player
    					(defer) <- await
    					player.giveBitsTo otherPlayer, 10bits, defer
    		# finally
    		board.endTurn!
    	or
    		<- icedCoffee (await) ->
    			if !player.creditor # creditor is the Bank
    				for let otherField in transferredFields
    					(defer) <- await
    					otherField.auction defer
    		# finally
    		board.endTurn!
    */
    icedCoffee = function(loopFn, finallyFn){
      var i, callbacks, res, await, defer;
      i = 0;
      callbacks = [];
      res = [];
      await = function(cb){
        return callbacks = callbacks.concat(cb);
      };
      defer = function(){
        var args;
        args = slice$.call(arguments);
        if (args.length > 1) {
          res[i] = args;
        } else {
          res[i] = args[0];
        }
        i++;
        if (i < callbacks.length) {
          return typeof callbacks[i] === 'function' ? callbacks[i](defer) : void 8;
        } else {
          return finallyFn(res);
        }
      };
      loopFn(await);
      if (callbacks.length) {
        return callbacks[0](defer);
      } else {
        return finallyFn([]);
      }
    };
  }.call(this, $('<span>')));
  setLanguage('en-US');
  Monopony = Board = (function(){
    Board.displayName = 'Board';
    var prototype = Board.prototype, constructor = Board;
    importAll$(prototype, arguments[0]);
    function Board(boardDiv, players){
      var board, i, attr, k, v, i$, ref$, len$, field, player, _, dl, name, this$ = this instanceof ctor$ ? this : new ctor$;
      players == null && (players = []);
      if (!boardDiv) {
        throw new TypeError("missing arguments");
      }
      board = this$;
      for (i in board) {
        attr = board[i];
        if (typeof attr === 'object' && attr != null) {
          board[i] = clone(attr);
        }
      }
      board.boardDiv = boardDiv;
      importAll$(board, (function(){
        var ref$, results$ = {};
        for (k in ref$ = {
          newPlayerDiv: '.statusBar-newPlayer',
          ownershipTokenContainer: '.ownershipToken-container',
          statusBar: '.statusBar',
          buttonsText: '.buttons-text',
          buttonsField: '.buttons',
          inputFieldError: '.input-error-text',
          avatarPicker: '.avatarPicker',
          avatarPickerTitle: '.avatarPicker-title',
          avatarPickerImgWrapper: '.avatarPicker-img-wrapper',
          avatarPickerCustomBtn: '.avatarPicker-custom-btn',
          avatarPickerCustomInput: '.avatarPicker-custom-input',
          consoleWrapper: '.console-wrapper',
          console: '.console',
          coins: '.coin',
          card: '.card',
          cardTitle: '.card-title',
          cardImage: '.card-image',
          cardText: '.card-text',
          cardButton: '.card-button',
          floatingCard: '.mini-card-floating',
          cloakDivs: '.cloak',
          businessMenu: '.business-menu'
        }) {
          v = ref$[k];
          results$[k] = board.boardDiv.find(v);
        }
        return results$;
      }()));
      board.avatarPickerImg = $();
      board.boardDiv.addClass('setup');
      for (i$ = 0, len$ = (ref$ = board.fields).length; i$ < len$; ++i$) {
        field = ref$[i$];
        field._board = board;
      }
      for (i$ = 0, len$ = (ref$ = players || []).length; i$ < len$; ++i$) {
        player = ref$[i$];
        board.addPlayer(player);
      }
      if (!board.players.length) {
        board.addPlayer();
      }
      if (board.players.length <= 2) {
        board.boardDiv.addClass('two-players');
      }
      board.shuffleDeck('chance');
      board.shuffleDeck('communityChest');
      board.newPlayerDiv.click(function(){
        if (board.setup) {
          board.boardDiv.removeClass('two-players');
          board.addPlayer().statusName.select();
          if (board.players.length >= 6) {
            return board.statusBar.stop().animate({
              scrollTop: 80 * board.players.length / 2 - 160
            }, 200);
          }
        }
      });
      _ = this$.avatarPickerCache;
      board.avatarPicker.click(function(){
        if (_.cancelAvatarPicker) {
          return board.hideAvatarPicker();
        } else {
          return _.cancelAvatarPicker = true;
        }
      });
      board.avatarPickerCustomInput.click(function(){
        return _.cancelAvatarPicker = false;
      }).input(throttle(500, function(){
        var avatar, url, customAvatar, ref$, host;
        avatar = board.avatarPickerCustomInput.val();
        if (in$(avatar, Monopony.customAvatars)) {
          url = Monopony.getAvatarUrl(avatar);
          customAvatar = true;
        } else {
          ref$ = $('<a>').prop('href', avatar)[0], url = ref$.href, host = ref$.host;
        }
        if (customAvatar || host !== location.host) {
          board.avatarPickerCustomInput.removeClass('input-incorrect');
          board.avatarPickerCustomBtn.prop('disabled', true).text("loading");
          _.newAvatar.remove();
          return _.newAvatar = $('<img>').prop('src', url).load(function(){
            board.avatarPickerImg.remove();
            board.avatarPickerImg = _.newAvatar.addClass('avatar');
            board.avatarPickerCustomBtn.prop('disabled', false).text("Apply");
            return _.newAvatar = $();
          }).appendTo(board.avatarPickerImgWrapper);
        } else {
          board.avatarPickerCustomInput.addClass('input-incorrect');
          return console.warn("[invalid avatar]", host, url);
        }
      }));
      board.avatarPickerCustomBtn.click(function(){
        var url;
        _.cancelAvatarPicker = false;
        if (!board.avatarPicker.hasClass('customAvatar')) {
          board.avatarPicker.addClass('customAvatar');
          board.avatarPickerCustomBtn.prop('disabled', true);
          board.avatarPickerCustomBtn.text("Apply");
          return board.avatarPickerCustomInput.focus();
        } else {
          url = board.avatarPickerCustomInput.val();
          if (in$(url, Monopony.customAvatars)) {
            url = Monopony.getAvatarUrl(url);
          } else {
            url = board.avatarPickerCustomInput.val();
          }
          _.player.changeAvatar(url, true);
          return board.hideAvatarPicker();
        }
      });
      if (!Monopony.nameDatalist) {
        Monopony.nameDatalist = true;
        dl = $('<datalist>');
        dl.prop('id', 'monopony_names_datalist');
        for (i$ = 0, len$ = (ref$ = Monopony.defaultNames).length; i$ < len$; ++i$) {
          name = ref$[i$];
          dl.append($('<option>').val(name));
        }
        dl.appendTo('body');
      }
      $('body').bind('mouseup', function(e){
        return Monopony.FieldMenu.mouseup(board, e);
      }).bind('mousemove', function(e){
        return Monopony.FieldMenu.mousemove(board, e);
      });
      board.reconnect();
      return this$;
    } function ctor$(){} ctor$.prototype = prototype;
    prototype.setup = true;
    prototype.players = [];
    prototype.bankruptPlayers = [];
    prototype.currentPlayer = null;
    prototype.currentPlayerNum = 0;
    prototype.chanceCards = [];
    prototype.communityChestCards = [];
    prototype.currentDice = [];
    prototype.gameEnded = false;
    prototype.fields = [];
    prototype.fieldGroups = {};
    prototype.businessMenus = {};
    prototype.slidin = null;
    prototype.sliderFieldMap = {};
    prototype.highlightedPlayer = null;
    prototype.avatarPickerCache = {};
    prototype.animationspeed = 150;
    prototype.bailout = 50;
    prototype.startBits = 1500;
    prototype.boardDiv = null;
    prototype.newPlayerDiv = null;
    prototype.ownershipTokenContainer = null;
    prototype.statusBar = null;
    prototype.buttonsText = null;
    prototype.buttonsField = null;
    prototype.consoleWrapper = null;
    prototype.console = null;
    prototype.coins = null;
    prototype.card = null;
    prototype.cardTitle = null;
    prototype.cardImage = null;
    prototype.cardText = null;
    prototype.cardButton = null;
    prototype.cardButtonCallback = function(){};
    prototype.floatingCard = null;
    prototype.businessMenu = null;
    prototype.avatarPickerCache = {};
    prototype.scale = 1;
    prototype.rotation = 0;
    prototype.isConnected = false;
    prototype.multiplayer = false;
    prototype.multiplayerDeferred = null;
    prototype.socket = null;
    prototype.room = null;
    prototype.rooms = {};
    prototype.isHost = false;
    prototype.multiplayerCallback = null;
    prototype.reqs = {};
    prototype.reqNum = 0;
    prototype.multiplayerStack = {};
    prototype.startMenu = function(dontClearConsole){
      var board, ref$;
      board = this;
      if (!dontClearConsole) {
        board.console.html("");
      }
      board.log("Please choose your name.");
      return board.buttons("Please select a Gamemode", (ref$ = {
        "SinglePlayer": function(){
          $('body').animate({
            scrollTop: $('#game').offset().top
          }, 'slow');
          board.addPlayer();
          board.newPlayerDiv.fadeIn();
          board.players[board.players.length - 1].statusName.select();
          return board.buttons({
            "Start Game": function(){
              return board.startGame();
            }
          });
        },
        "Test Multiplayer": function(){
          $('body').animate({
            scrollTop: $('#game').offset().top
          }, 'slow');
          return board.initMultiplayer().timeoutDeferred(500, function(){
            return board.log("loading...");
          }).then(function(socket, emit){
            return board.gotoLobby();
          }).fail(function(err){
            board.log("An error occured while trying to connect to the multiplayer server.");
            board.log("Maybe the server is down?");
            board.log("\n===================\n");
            return board.startMenu(true);
          });
        }
      }, ref$[window.debug.title + ""] = window.debug.fn, ref$));
    };
    prototype.startGame = function(){
      var board, errors, errorTxt, i$, ref$, len$, player;
      board = this;
      errors = board.checkForErrorneousNames();
      if (errors) {
        if (errors.length > 1) {
          errorTxt = "some Errors occured:\n" + list(errors);
        } else {
          errorTxt = errors[0];
        }
        board.msgBox(errorTxt);
        board.buttons(errorTxt, {
          "Start Game": function(){
            return board.startGame();
          }
        });
        return;
      }
      for (i$ = 0, len$ = (ref$ = board.players).length; i$ < len$; ++i$) {
        player = ref$[i$];
        player.bits = board.startBits;
        if (board.setup && !player.remote) {
          player.statusName.remove();
          player.statusName = $('<div>').addClass('statusBar-playerName').text(player.name).insertBefore(player.statusBits);
        }
        player.status.removeClass('active');
      }
      board.currentPlayer = board.players[0];
      board.currentPlayer.status.addClass('active');
      board.setup = false;
      board.boardDiv.removeClass('setup');
      board.newPlayerDiv.fadeOut();
      board.trigger('newGame', board);
      board.startTurn();
      return board.update();
    };
    prototype.update = function(){
      var board, i$, ref$, len$, player, results$ = [];
      board = this;
      for (i$ = 0, len$ = (ref$ = board.players).length; i$ < len$; ++i$) {
        player = ref$[i$];
        player.statusBits.text(plural(player.bits, 'bit') + "");
        results$.push(player.statusLocation.text("(" + board.fields[player.position].name + ")"));
      }
      return results$;
    };
    prototype.cleanUp = function(){
      var board, i$, ref$, len$, field, playerHelper, nameSpan, j$, len1$, player;
      board = this;
      board.gameEnded = false;
      for (i$ = 0, len$ = (ref$ = board.fields).length; i$ < len$; ++i$) {
        field = ref$[i$];
        field.cleanUp();
      }
      playerHelper = board.players.concat(board.bankruptPlayers);
      board.players = [];
      for (i$ = 0, len$ = (ref$ = board.boardDiv.find('.statusBar-playerName')).length; i$ < len$; ++i$) {
        nameSpan = ref$[i$];
        for (j$ = 0, len1$ = playerHelper.length; j$ < len1$; ++j$) {
          player = playerHelper[j$];
          if (player.name === $(nameSpan).text()) {
            board.players = board.players.concat(player);
            break;
          }
        }
      }
      for (i$ = 0, len$ = (ref$ = board.players).length; i$ < len$; ++i$) {
        player = ref$[i$];
        player.cleanUp();
      }
      return board.update();
    };
    prototype.gameEnd = function(){
      var player;
      player = board.players[0];
      board.gameEnded = true;
      board.msgBox("" + player.name + " WON THE GAME!");
      return board.buttons("Back to Start Menu", function(){
        return board.startMenu();
      });
    };
    prototype.checkForErrorneousNames = function(player){
      var board, playersWithSameName, playersWithErrorneousName, errors, takenNames, players, i$, len$;
      board = this;
      playersWithSameName = [];
      playersWithErrorneousName = [];
      errors = {
        short: [],
        long: []
      };
      takenNames = board.players.map(function(it){
        return it.name;
      });
      if (player) {
        players = [player];
      } else {
        players = board.players;
      }
      for (i$ = 0, len$ = players.length; i$ < len$; ++i$) {
        player = players[i$];
        if (player.name === "") {
          errors.short = errors.short.concat("Enter a name!");
          errors.long = errors.long.concat("Please give the " + xth(i) + " player a name!");
        } else if (["bank", "the bank", "(the) bank"].filter(fn$).length !== 0) {
          errors.short = errors.short.concat("Disallowed name!");
          errors.long = errors.long.concat("The " + xth(i) + " player may not be named '(The) Bank'!");
        } else if (player.name.length >= 15) {
          errors.short = errors.short.concat("Name too long!");
          errors.long = errors.long.concat(player.name + "'s name is too long. Only 14 characters are allowed.");
        } else if (takenNames.filter(fn1$).length > 1) {
          playersWithSameName = playersWithSameName.concat(player);
        } else {
          continue;
        }
        player.status.addClass('error');
        playersWithErrorneousName = playersWithErrorneousName.concat(player);
      }
      if (playersWithSameName.length) {
        for (i$ = 0, len$ = playersWithSameName.length; i$ < len$; ++i$) {
          (fn2$.call(this, playersWithSameName[i$]));
        }
        errors.short = errors.short.concat("Not a unique name!");
        errors.long = errors.long.concat("There are some players with the name " + list(playersWithSameName.map(function(it){
          return '"' + it.name + '"';
        })) + ".\nEach player has to have a unique name!");
      }
      if (errors.short.length) {
        for (i$ = 0, len$ = playersWithErrorneousName.length; i$ < len$; ++i$) {
          (fn3$.call(this, playersWithErrorneousName[i$]));
        }
        if (player) {
          return errors.short;
        } else {
          return errors.long;
        }
      } else {
        return false;
      }
      function fn$(b){
        return strCompare_i(b, player.name);
      }
      function fn1$(otherName){
        return strCompare_i(otherName, player.name);
      }
      function fn2$(player){
        player.statusName.one('change', function(){
          var i$, ref$, len$, otherPlayer, results$ = [];
          for (i$ = 0, len$ = (ref$ = playersWithSameName).length; i$ < len$; ++i$) {
            otherPlayer = ref$[i$];
            results$.push(otherPlayer.status.removeClass('error'));
          }
          return results$;
        });
      }
      function fn3$(player){
        player.status.addClass('error');
        player.statusName.one('change', function(){
          return player.status.removeClass('error');
        });
      }
    };
    prototype.addPlayer = function(options, avatar){
      var board, player;
      board = this;
      if (typeof options === 'string') {
        options = {
          name: options,
          avatar: avatar
        };
      }
      player = new Monopony.Player(this, options);
      board.players.push(player);
      return player;
    };
    prototype.removePlayer = function(player, noAnimation){
      var board;
      board = this;
      board.players.splice(board.players.indexOf(player, 1));
      player.status.fadeOut(noAnimation ? 0 : 'slow', function(){
        player.image.remove();
        return player.status.remove();
      });
      if (board.players.length <= 2 && !board.multiplayer) {
        return board.boardDiv.addClass('two-players');
      }
    };
    prototype.applyOptions = function(options){
      var board;
      board = this;
      if (options.startBits) {
        return board.startBits = options.startBits;
      }
    };
    prototype.nextPlayer = function(){
      var board, player;
      board = this;
      player = board.players[board.currentPlayerNum];
      board.currentPlayerNum = (board.currentPlayerNum + 1) % board.players.length;
      player = board.currentPlayer = board.players[board.currentPlayerNum];
      player.status.addClass('active');
      board.statusBar.stop().animate({
        scrollTop: 80 * board.currentPlayerNum / 2 - 160
      }, 200);
      board.log("=============\nNow it's " + player.name + "'s turn.");
      board.trigger('nextTurn', board, player);
      return board.startTurn();
    };
    prototype.startTurn = function(autoRollDice){
      var board, player, hasCard, ref$, helper;
      board = this;
      player = this.currentPlayer;
      board.update();
      if (board.gameEnded) {
        return;
      }
      if (player.isParking) {
        player.isParking = false;
        board.log(player.name + " is still parking.");
        return board.endTurn();
      } else if (player.isOnTheMoon) {
        hasCard = player.returnFromTheMoonCards > 0 ? "" : "#";
        return board.buttons((ref$ = {
          "Try to roll doubles": function(){
            return player.rollDice(function(board, die){
              board.log(player.name + " rolled " + die[0] + " and " + die[1]);
              if (die[0] === die[1]) {
                board.log(player.name + " comes back from the moon and moves " + die.sum + " fields.");
                player.isOnTheMoon = 0;
                return board.buttons("Move " + plural(die.sum, 'field'), function(){
                  board.log(player.name + " moved " + plural(die.sum, 'field') + ".");
                  return player.move(die.sum);
                });
              } else if (player.isOnTheMoon++ === 3) {
                board.log(player.name + " is charged with " + plural(board.bailout, 'bit') + ".");
                return board.buttons("Pay " + plural(board.bailout, 'bit') + ".", function(){
                  return player.pay(board.bailout, function(){
                    board.log(player.name + " pays the bailout of " + plural(board.bailout, 'bit') + " and comes back from the moon");
                    player.isOnTheMoon = 0;
                    return board.endTurn();
                  });
                });
              } else {
                return board.endTurn();
              }
            });
          }
        }, ref$["Pay " + plural(board.bailout, 'bit') + " Bailout"] = function(){
          board.log(player.name + " pays the bailout of " + plural(board.bailout, 'bit') + " and comes back from the moon");
          return player.pay(board.bailout, function(){
            player.isOnTheMoon = 0;
            return board.endTurn();
          });
        }, ref$[hasCard + " Use Return-From-the-Moon Card"] = function(){
          board.log(player.name + " used a Return-From-the-Moon card to come back from the moon");
          player.returnFromTheMoonCards--;
          player.isOnTheMoon = 0;
          return board.startTurn();
        }, ref$));
      }
      helper = function(){
        return player.rollDice(function(arg$, dice){
          board.currentDice = dice;
          board.log(player.name + " rolled a " + number(dice[0]) + " and a " + number(dice[1]));
          if (dice[0] === dice[1]) {
            player.doubles++;
          } else {
            player.doubles = 0;
          }
          if (player.doubles === 3) {
            board.log(player.name + " rolled three consecutive doubles. Due to breaking Monopony law, " + player.name + " has to go to jail.");
            player.doubles = 0;
            return player.buttons("Go to Jail", function(){
              player.toTheMoon();
              return board.endTurn();
            });
          } else {
            return player.move(dice[0] + dice[1], function(){
              return player.processField();
            });
          }
        });
      };
      if (autoRollDice) {
        return helper();
      } else {
        return player.buttons("Roll the Dice", helper);
      }
    };
    prototype.endTurn = function(){
      var board, player;
      board = this;
      player = this.currentPlayer;
      if (board.gameEnded) {
        return board.buttons("Back to Start Menu", function(){
          board.cleanUp();
          return board.startMenu();
        });
      } else if (player.lost) {
        return board.nextPlayer();
      } else {
        if (player.doubles) {
          board.log("=============\n" + player.name + " rolled doubles and thus may roll again.");
          return player.buttons({
            "Roll Dice Again": function(){
              return board.startTurn(true);
            },
            "Business": function(){
              return board.openBusinessMenu();
            }
          });
        } else {
          return player.buttons({
            "End Turn": function(){
              board.socket.emit('endTurn');
              player.status.removeClass('active');
              return board.nextPlayer();
            },
            "Business": function(){
              return board.openBusinessMenu();
            }
          });
        }
      }
    };
    prototype.openBusinessMenu = function(player, callback){
      var Monopony, board;
      callback == null && (callback = arguments[0] || function(){});
      Monopony = constructor;
      board = this;
      if (!player || !in$(player, board.players)) {
        player = board.currentPlayer;
      }
      return sleep(1, function(){
        var btnTradeCards, canceled, fieldSelCallback, btnRepayDebt, btnGiveUp, btnBack, callback, debtor, creditor, bank, ref$;
        if (board.players.filter(function(it){
          return it.returnFromTheMoonCards;
        }).length) {
          btnTradeCards = "";
        } else {
          btnTradeCards = '#';
        }
        canceled = false;
        fieldSelCallback = function(e){
          var field, otherFields, i$, len$, otherField;
          if (canceled) {
            return;
          }
          canceled = true;
          field = board.getFieldByPos(e, true);
          if (!field || !field.buyable) {
            if (!$(e.target).is('button')) {
              board.hideBusinessMenu();
              board.openBusinessMenu(player, callback);
            }
            return;
          }
          field.reveal();
          otherFields = importAll$([], board.fieldGroups[field.group]);
          if (field.index < board.fields.length) {
            otherFields = otherFields.reverse();
          }
          board.businessMenu.show();
          for (i$ = 0, len$ = otherFields.length; i$ < len$; ++i$) {
            otherField = otherFields[i$];
            board.businessMenus[otherField.index] = new Monopony.FieldMenu(otherField, player, otherField === field);
          }
          board.buttons("Back", function(){
            return board.reloadBusinessMenu();
          });
        };
        btnRepayDebt = '#';
        btnGiveUp = '#';
        btnBack = '#';
        if (player.owes) {
          if (typeof callback !== 'function') {
            callback = function(){
              return board.endTurn();
            };
          }
          debtor = player;
          creditor = debtor.creditor;
          bank = creditor === null;
          if (debtor.bits >= debtor.owes) {
            btnRepayDebt = "";
          } else {
            btnGiveUp = "";
          }
        } else {
          btnBack = "";
        }
        board.buttons("click on the field you want to work with", (ref$ = {
          $always: function(){
            board.boardDiv.unbind('click', fieldSelCallback);
            return canceled = true;
          }
        }, ref$[btnRepayDebt + " Repay Debt"] = function(){
          if (bank) {
            board.log(debtor.name + " pays the Bank " + plural(debtor.owes, 'bit'));
            board.uncloak();
            return debtor.pay(debtor.owes, function(){
              debtor.owes = 0;
              return callback();
            });
          } else {
            board.log(debtor.name + " pays " + creditor.name + " " + plural(debtor.owes, 'bit'));
            board.uncloak();
            return debtor.giveBitsTo(creditor, debtor.owes, function(){
              debtor.owes = 0;
              debtor.creditor = null;
              return callback();
            });
          }
        }, ref$[btnGiveUp + " Give Everything to Creditor"] = function(){
          var log_, ui_, transferredFields, i$, ref$, len$, otherField;
          board.uncloak();
          log_ = board.log;
          ui_ = board.ui;
          board.log = board.ui = function(){};
          transferredFields = [];
          for (i$ = 0, len$ = (ref$ = board.fields).length; i$ < len$; ++i$) {
            otherField = ref$[i$];
            if (otherField.owner === debtor) {
              if (!otherField.utility && field.houses > 0) {
                field.setHouses(0);
              }
              transferredFields = transferredFields.concat(field);
            }
          }
          if (!bank) {
            for (i$ = 0, len$ = transferredFields.length; i$ < len$; ++i$) {
              otherField = transferredFields[i$];
              field.changeOwner(creditor);
            }
          }
          board.log = log_;
          board.ui = ui_;
          if (creditor && debtor.bits) {
            board.log(debtor.name + " gives " + plural(debtor.bits, 'bit') + " and " + list(transferredFields.map(function(it){
              return it.name;
            })) + " to " + creditor.name);
            debtor.giveBitsTo(creditor, debtor.bits);
          } else {
            board.log(debtor.name + " gives " + plural(debtor.bits, 'bit') + " and " + list(transferredFields.map(function(it){
              return it.name;
            })) + " to the Bank");
            debtor.pay(debtor.bits);
          }
          return debtor.gameover(function(){
            return icedCoffee(function(await){
              var i$, len$, results$ = [];
              if (bank) {
                for (i$ = 0, len$ = transferredFields.length; i$ < len$; ++i$) {
                  results$.push((fn$.call(this, transferredFields[i$])));
                }
                return results$;
              }
              function fn$(otherField){
                return await(function(defer){
                  var pos;
                  console.log("field", otherField);
                  pos = otherField.getPos();
                  board.cloak(pos[0], pos[1], pos[2], pos[3]);
                  board.buttons("The Bank auctions " + otherField.name, "Continue");
                  return board.auctionField(otherField, defer);
                });
              }
            }, function(){
              board.uncloak();
              board.update();
              return callback();
            });
          });
        }, ref$[btnTradeCards + " Trade Cards"] = function(){
          var helperSelPlayer;
          return (helperSelPlayer = function(){
            return board.selectPlayerForTrade(player, function(otherPlayer){
              var btnBuyCards, btnSellCards, ref$;
              if (otherPlayer.returnFromTheMoonCards) {
                btnBuyCards = "";
              } else {
                btnBuyCards = '%';
              }
              if (player.returnFromTheMoonCards) {
                btnSellCards = "";
              } else {
                btnSellCards = '%';
              }
              return board.buttons((ref$ = {}, ref$[btnBuyCards + " Buy Cards"] = function(){
                return board.tradeCard(otherPlayer, player, false, function(){
                  return board.reloadBusinessMenu();
                });
              }, ref$[btnSellCards + " Sell Cards"] = function(){
                return board.tradeCard(player, otherPlayer, false, function(){
                  return board.reloadBusinessMenu();
                });
              }, ref$["Back"] = function(){
                return helperSelPlayer();
              }, ref$));
            });
          })();
        }, ref$[btnBack + " Back"] = function(){
          board.hideBusinessMenu();
          return board.nextPlayer();
        }, ref$));
        board.boardDiv.one('click', fieldSelCallback);
      });
    };
    prototype.hideBusinessMenu = function(){
      var i$, ref$, otherMenu;
      board.uncloak();
      for (i$ in ref$ = board.businessMenus) {
        otherMenu = ref$[i$];
        if (typeof otherMenu.remove === 'function') {
          otherMenu.remove();
        }
      }
      return board.businessMenu.hide();
    };
    prototype.reloadBusinessMenu = function(){
      board.hideBusinessMenu();
      return board.openBusinessMenu();
    };
    prototype.auctionField = function(field, callback){
      var board, price, playerBitmap, playerBitmapLength, len, i, bidder, helper;
      board = this;
      callback == null && (callback = function(){
        return board.endTurn();
      });
      board.log(field.name + " is up for auction");
      price = 0;
      playerBitmap = {};
      playerBitmapLength = board.players.length;
      len = board.players.length;
      i = board.currentPlayerNum;
      return (helper = function(){
        i = (i + 1) % len;
        bidder = board.players[i];
        if (playerBitmapLength <= 1) {
          alert("auction ended");
          if (price === 0) {
            if (bidder.bits) {
              return bidder.input('number', ["Buy", "Don't Buy"], {
                text: bidder.name.toUpperCase() + ": what do you want to pay for this field?",
                'default': 1,
                validate: function(value){
                  if (value > player.bits) {
                    return "You don't even have " + plural(value, 'bit') + "!";
                  } else if (value < 1) {
                    return "You have to pay at least " + plural(1, 'bit');
                  } else {
                    return true;
                  }
                },
                callback: function(board, value, btn){
                  bidder.unhighlight();
                  if (btn === 0) {
                    board.log("" + bidder.name + " won the auction.\n" + bidder.name + " pays " + plural(value, 'bit') + " for " + field.name + ".");
                    field.buy(bidder, value);
                    callback();
                  } else {
                    board.log("The auction ended. Nopony wanted to buy " + field.name + ".");
                    callback();
                  }
                }
              });
            } else {
              board.log("" + bidder.name + " doesn't have enough bits to buy " + field.name + ".\nThe auction ended. " + field.name + " remains unowned.");
              callback();
            }
          } else {
            bidder.unhighlight();
            board.log("" + bidder.name + " won the auction.\n" + bidder.name + " pays " + plural(price, 'bit') + " for " + field.name + ".");
            field.buy(bidder, price);
            callback();
          }
        } else if (playerBitmap[i]) {
          return board.log(bidder.name + " may not bid anymore");
        } else if (bidder.bits <= price) {
          board.log(bidder.name + " has not enough bits to place a bid");
          playerBitmap[i] = true;
          return playerBitmapLength--;
        } else {
          bidder.highlight();
          return bidder.input('number', ["Bid", "Don't Bid"], {
            text: bidder.name.toUpperCase() + ": Enter your bid:",
            'default': price + 1,
            validate: function(value){
              if (value > player.bits) {
                return "You don't even have " + plural(value, 'bit') + "!";
              } else if (value <= price) {
                return "You have to bid higher than " + plural(price, 'bit') + "!";
              } else {
                return true;
              }
            },
            callback: function(board, value, btn){
              bidder.unhighlight();
              if (btn === 0) {
                price = value;
                board.log(bidder.name + " bid " + plural(price, 'bit') + ".");
              } else {
                playerBitmap[i] = true;
                playerBitmapLength--;
                board.log(bidder.name + " passes.");
              }
              return helper();
            }
          });
        }
      })();
    };
    prototype.showAvatarPicker = function(player){
      var Monopony, board, _, i$, len$;
      Monopony = constructor;
      board = this;
      _ = this.avatarPickerCache;
      _.player = player;
      _.cancelAvatarPicker = true;
      if (!board.setup) {
        return;
      }
      _.avatars = $();
      _.newAvatar = $();
      board.avatarPickerImg = $('<img>').addClass('avatar');
      if (player.avatarIsCustom) {
        board.avatarPickerImg.prop('src', player.avatar);
      } else {
        board.avatarPickerImg.prop('src', Monopony.getAvatarUrl(player.avatar));
      }
      board.avatarPickerImg.appendTo(board.avatarPickerImgWrapper);
      for (i$ = 0, len$ = Monopony.defaultNames.length; i$ < len$; ++i$) {
        (fn$.call(this, Monopony.defaultNames[i$]));
      }
      return board.avatarPicker.fadeIn();
      function fn$(name){
        _.avatars = _.avatars.add($('<figure>').addClass('avatarPicker-avatar').append($('<img>').addClass('avatar').prop('src', Monopony.getAvatarUrl(name))).append($('<figcaption>').text(name)).appendTo(board.avatarPicker).click(function(){
          _.cancelAvatarPicker = false;
          player.changeAvatar(name);
          return board.hideAvatarPicker();
        }));
      }
    };
    prototype.hideAvatarPicker = function(){
      var board, _;
      board = this;
      _ = this.avatarPickerCache;
      return board.avatarPicker.fadeOut(function(){
        _.avatars.remove();
        board.avatarPicker.removeClass('customAvatar');
        board.avatarPickerCustomBtn.text("Use custom Avatar").prop('disabled', false);
        _.newAvatar.remove();
        return board.avatarPickerImg.remove();
      });
    };
    prototype.getFieldByPos = function(pos, absolute){
      var Monopony, board, x, y, fieldHeight, fieldWidth, fieldOffset, boardWidth, x$, f;
      Monopony = constructor;
      board = this;
      if (typeof pos === 'object' && pos !== null) {
        x = pos.x, y = pos.y;
        x == null && (x = pos.pageX), y == null && (y = pos.pageY);
      } else if (!isNaN(arguments[0]) && !isNaN(arguments[1])) {
        x = arguments[0];
        y = arguments[1];
        absolute = arguments[2];
      } else {
        throw new TypeError("invalid arguments (could not get coordinates)\narguments can be passed as (x, y) or ({x: x, y: y}) or ({pageX: x, pageY: y, â€¦})");
      }
      fieldHeight = Monopony.fieldHeight, fieldWidth = Monopony.fieldWidth, fieldOffset = Monopony.fieldOffset, boardWidth = Monopony.boardWidth;
      if (absolute) {
        x$ = board.boardDiv.offset();
        x -= x$.left;
        y -= x$.top;
      }
      console.log("[getFbP]", x, y);
      if (!(0 < x && x < boardWidth) || !(0 < y && y < boardWidth)) {
        return;
      }
      x /= board.scale;
      y /= board.scale;
      if (y <= fieldHeight) {
        if (x <= fieldHeight) {
          f = 20;
        } else if (x >= fieldOffset) {
          f = 30;
        } else {
          f = 20 + Math.ceil((x - fieldHeight) / fieldWidth);
        }
      } else if (y > fieldOffset) {
        if (x <= fieldHeight) {
          f = 10;
        } else if (x >= fieldOffset) {
          f = 0;
        } else {
          f = 0 + Math.ceil((fieldOffset - x) / fieldWidth);
        }
      } else if (x <= fieldHeight) {
        f = 10 + Math.ceil((fieldOffset - y) / fieldWidth);
      } else if (x >= fieldOffset) {
        f = 40 - Math.ceil((fieldOffset - y) / fieldWidth);
      }
      return board.fields[f];
    };
    prototype.rollDice = function(callback){
      var board, dice;
      board = this;
      dice = [Math.ceil(Math.random() * 6), Math.ceil(Math.random() * 6)];
      dice.sum = dice[0] + dice[1];
      return callback(this, dice);
    };
    prototype.shuffleDeck = function(deck){
      var board;
      board = this;
      board[deck + "Cards"] = importAll$([], Monopony[deck + "Cards"]);
      return board[deck + "Cards"].shuffle();
    };
    prototype.getPlayer = function(nameOrNumOrPlayer){
      var board, i$, ref$, len$, player;
      board = this;
      if (board.players.length > +nameOrNumOrPlayer && !isNaN(nameOrNumOrPlayer)) {
        return board.players[+nameOrNumOrPlayer];
      } else if (typeof nameOrNumOrPlayer === 'string') {
        for (i$ = 0, len$ = (ref$ = board.players).length; i$ < len$; ++i$) {
          player = ref$[i$];
          if (player.name === nameOrNumOrPlayer) {
            return player;
          }
        }
      } else if (in$(nameOrNumOrPlayer, board.players)) {
        return nameOrNumOrPlayer;
      }
    };
    prototype.getField = function(nameOrNumOrField){
      var board, i$, ref$, len$, field;
      board = this;
      if (board.fields.length > +nameOrNumOrField && !isNaN(nameOrNumOrField)) {
        return board.fields[+nameOrNumOrField];
      } else if (typeof nameOrNumOrField === 'string') {
        for (i$ = 0, len$ = (ref$ = board.fields).length; i$ < len$; ++i$) {
          field = ref$[i$];
          if (strCompare_i(field.name, $.trim(nameOrNumOrField))) {
            return field;
          }
        }
      } else if (in$(nameOrNumOrField, board.fields)) {
        return nameOrNumOrField;
      }
    };
    prototype.buttons = function(){
      var board, text, btns, callback, ref$, always, noAnimation, i_, i$;
      board = this;
      if (typeof arguments[0] === 'object') {
        text = "";
        btns = arguments[0];
        callback = arguments[1];
      } else if (typeof arguments[0] === 'string' && typeof arguments[1] === 'string') {
        text = arguments[0];
        btns = (ref$ = {}, ref$[arguments[1] + ""] = arguments[2], ref$);
        callback = arguments[3];
      } else if (typeof arguments[0] === 'string' && typeof arguments[1] === 'object') {
        text = arguments[0];
        btns = arguments[1];
        callback = arguments[2];
      } else if (typeof arguments[0] === 'string' && typeof arguments[1] === 'function') {
        text = "";
        btns = (ref$ = {}, ref$[arguments[0] + ""] = arguments[1], ref$);
        callback = arguments[2];
      }
      /*! special triggers: (need to be the first char of the btn's key)
      	% -> disabled
      	# -> hidden
      	$ -> special
      		$always -> callback that gets called after any button
      		$noAnimation -> buttons don't get faded in
      		$async?
      */
      board.buttonsText.text(text);
      board.buttonsField.find('button').remove();
      if (!btns) {
        return;
      }
      always = callback || btns.$always;
      noAnimation = btns.$noAnimation;
      i_ = 0;
      for (i$ in btns) {
        (fn$.call(this, i$, btns[i$]));
      }
      return board.trigger('buttons');
      function fn$(btn, callback){
        var i, ref$, btnEl;
        i = i_;
        if ((ref$ = btn[0]) === '$' || ref$ === '#') {
          return;
        }
        if (btn[0] === '%') {
          btnEl = $('<button>').text(btn.substring(2)).attr('disabled', true);
        } else {
          btnEl = $('<button>').text(btn).click(function(){
            board.buttonsField.html("");
            callback(board, btn, i);
            return typeof always === 'function' ? always(board, btn, i) : void 8;
          });
        }
        btnEl.hide().appendTo(board.buttonsField);
        if (!noAnimation) {
          btnEl.fadeIn();
        } else {
          btnEl.show();
        }
        i_++;
      }
    };
    prototype.input = function(type, btns, arg$){
      var defaultArg, text, validate, callback, ref$, board, wasIncorrect, validateWrapper, btnsReqVal, i$, len$;
      defaultArg = arg$['default'], text = arg$.text, validate = arg$.validate, callback = (ref$ = arg$.callback) != null
        ? ref$
        : function(){};
      board = this;
      type = safeToString(type).trim().toLowerCase();
      if (not$(type === 'text' || type === 'password' || type === 'search' || type === 'email' || type === 'url' || type === 'tel' || type === 'number' || type === 'range' || type === 'date' || type === 'month' || type === 'week' || type === 'time' || type === 'datetime' || type === 'datetime-local' || type === 'color')) {
        throw new Error("unknown type for <input>");
      }
      wasIncorrect = false;
      validateWrapper = function(input){
        var isIncorrect, that, validation, i$, ref$, len$, $btn;
        if (type === 'number') {
          input = +input;
          if (isNaN(input)) {
            return "Please enter a valid number!";
          } else if (input % 1) {
            board.boardDiv.addClass('input-incorrect');
            board.inputFieldError.text("Splitting bits in half is an Equestrian federal crime!");
            isIncorrect = true;
          }
        }
        if (typeof validation === 'string') {
          board.boardDiv.addClass('input-incorrect');
          board.inputFieldError.text(validation);
          isIncorrect = true;
        } else if (that = typeof validate === 'function' ? validate(input) : void 8) {
          validation = that;
          if (typeof validation === 'string') {
            board.inputFieldError.text(validation || "");
            board.boardDiv.addClass('input-incorrect');
            isIncorrect = true;
          } else if (!validation) {
            board.boardDiv.addClass('input-incorrect');
            isIncorrect = true;
          } else {
            board.boardDiv.removeClass('input-incorrect');
            isIncorrect = false;
          }
        } else {
          board.boardDiv.removeClass('input-incorrect');
          isIncorrect = false;
        }
        if (!wasIncorrect && isIncorrect) {
          for (i$ = 0, len$ = (ref$ = btnsReqVal).length; i$ < len$; ++i$) {
            $btn = ref$[i$];
            $btn.attr('disabled', true);
          }
        } else if (wasIncorrect && !isIncorrect) {
          for (i$ = 0, len$ = (ref$ = btnsReqVal).length; i$ < len$; ++i$) {
            $btn = ref$[i$];
            $btn.removeAttr('disabled');
          }
        }
        wasIncorrect = isIncorrect;
        return !isIncorrect;
      };
      board.buttonsField.find('button').remove();
      board.buttonsText.text(text || "");
      board.inputField = $("<input type='" + type + "'>").addClass('inputField').val(defaultArg).input(throttle(100, function(){
        var input;
        input = board.inputField.val();
        return validateWrapper(input);
      })).appendTo(board.buttonsField);
      btnsReqVal = [];
      for (i$ = 0, len$ = btns.length; i$ < len$; ++i$) {
        (fn$.call(this, i$, btns[i$]));
      }
      return board.boardDiv.addClass('showInputField');
      function fn$(btn, btnText){
        var requiresValidity, $btn;
        requiresValidity = btnText.charAt(0) === 'Â§';
        if (requiresValidity) {
          btnText = btnText.substring(2);
        }
        $btn = $('<button>').text(btnText).click(function(){
          var input;
          input = board.inputField.val();
          if (type === 'number') {
            input = +input;
          }
          if (requiresValidity && !validateWrapper(input)) {
            return board.inputField.trigger('shake');
          } else {
            board.buttonsField.html("");
            return callback(board, input, btn);
          }
        }).hide().appendTo(board.buttonsField).fadeIn();
        if (requiresValidity) {
          btnsReqVal = btnsReqVal.concat($btn);
        }
      }
    };
    prototype.selectPlayer = function(players, text, callback){
      var board, pos, ref$, canceled, playerSelCallback;
      players == null && (players = this.players);
      board = this;
      pos = board.statusBar.offset();
      ref$ = {
        left: (ref$ = board.boardDiv.offset()).left,
        top: ref$.top
      }, pos.left -= ref$.left, pos.top -= ref$.top;
      board.cloak(pos.left, pos.top, board.statusBar.width(), board.statusBar.height());
      if (players.length === 1) {
        callback(players[0]);
      } else if (players.length === 0) {
        callback(false);
      }
      canceled = false;
      playerSelCallback = function(otherPlayer){
        if (canceled) {
          return;
        }
        canceled = true;
        board.uncloak();
        return callback(otherPlayer);
      };
      board.buttons("Click on the player who you want trade with", {
        "Cancel": function(){
          canceled = true;
          board.unbind('playerClicked', playerSelCallback);
          board.uncloak();
          return callback(false);
        }
      });
      return board.once('playerClicked', playerSelCallback);
    };
    prototype.selectPlayerForTrade = function(sellerOrPlayers, callback){
      var players;
      if ($.isArray(sellerOrPlayers)) {
        players = sellerOrPlayers;
      } else {
        players = board.players.sans(sellerOrPlayers);
      }
      return board.selectPlayer(players, "Click on the player who you want trade with", function(otherPlayer){
        if (otherPlayer) {
          return callback(otherPlayer);
        } else {
          return board.reloadBusinessMenu();
        }
      });
    };
    prototype.log = function(text, callback, button){
      var board;
      if (typeof text !== 'string') {
        text = text + "";
      }
      board = this;
      board.console.append($('<div>').html(text.replace(/\n/g, "<br>")));
      board.consoleWrapper.stop().animate({
        scrollTop: board.console.height()
      }, 1000);
      if (typeof callback === 'function') {
        return callback();
      }
    };
    prototype.msgBox = function(text, callback, button){
      board.log(text);
      return alert(text);
    };
    prototype.cloak = function(x, y, w, h){
      var board, boardW, boardH;
      board = this;
      boardW = board.boardDiv.width();
      boardH = board.boardDiv.height();
      board.cloakDivs.eq(0).css({
        left: 0,
        top: 0,
        width: boardW,
        height: y
      });
      board.cloakDivs.eq(1).css({
        left: x + w,
        top: y,
        width: boardW - x,
        height: h
      });
      board.cloakDivs.eq(2).css({
        left: 0,
        top: y,
        width: x,
        height: h
      });
      board.cloakDivs.eq(3).css({
        left: 0,
        top: y + h,
        width: boardW,
        height: boardH - y - h
      });
      return board.cloakDivs.animate({
        opacity: 1
      }, 400);
    };
    prototype.uncloak = function(){
      var board;
      board = this;
      return board.cloakDivs.animate({
        opacity: 0
      }, 400, function(){
        return board.cloakDivs.css({
          top: 0,
          left: 0,
          width: 0,
          height: 0
        });
      });
    };
    prototype.ui = function(type){
      var board, player, deck, card, otherDeck, callback, amount, receiver, steps, helper;
      board = this;
      player = board.currentPlayer;
      switch (type) {
      case 'drawCard':
        deck = arguments[1];
        card = arguments[2];
        otherDeck = deck === 'chance' ? 'communityChest' : 'chance';
        board.log(player.name + " drew the card '" + card.title + "'.");
        board.log(card.text);
        board.cardTitle.text(card.title);
        board.cardImage.attr('src', "images/cards/" + card.image + ".png");
        board.cardText.text_fixed_br(card.text);
        board.floatingCard.removeClass("mini-card-" + otherDeck + "Card").addClass("mini-card-" + deck + "Card").css(deck === 'chance'
          ? {
            left: 542
          }
          : {
            left: 175
          });
        return board.floatingCard.stop().animate(deck === 'chance'
          ? {
            left: 894
          }
          : {
            left: -175
          }, function(){
          return board.card.css(deck === 'chance'
            ? {
              left: 894
            }
            : {
              left: -230
            }).stop().animate({
            left: 332
          });
        });
      case 'hideCard':
        deck = arguments[1];
        card = arguments[2];
        callback = arguments[3];
        return board.card.stop().animate({
          left: 894
        }, callback);
      case 'updateCarddeck':
        return deck = arguments[1];
      case 'bits':
        player = arguments[1];
        amount = arguments[2];
        receiver = arguments[3];
        if (!amount) {
          return;
        }
        board.update();
        if (player.bits > 0) {
          board.log(player.name + " now has " + plural(player.bits, 'bit') + ".");
        }
        steps = 1 + Math.floor(Math.abs(amount / 100));
        helper = function(offset, amount, start_index){
          var i$, to$, results$ = [];
          for (i$ = start_index, to$ = start_index + steps; i$ <= to$; ++i$) {
            results$.push((fn$.call(this, i$)));
          }
          return results$;
          function fn$(i){
            var coin;
            coin = board.coins.eq(i);
            if (!coin) {
              coin = board.coins.append($('div')).addClass('coin');
            }
            if (amount > 0) {
              coin.css({
                top: offset.top - 40,
                opacity: 1,
                left: offset.left + 110
              });
              return sleep(300 * i, function(){
                return board.coins.eq(i).stop().animate({
                  top: offset.top
                }, 300).animate({
                  opacity: 0
                }, 500);
              });
            } else if (amount < 0) {
              coin.css({
                top: offset.top,
                opacity: 1,
                left: offset.left + 110
              });
              return sleep(300 * i, function(){
                return board.coins.eq(i).stop().animate({
                  top: offset.top - 40
                }, 300).animate({
                  opacity: 0
                }, 500);
              });
            }
          }
        };
        helper(player.status.offset(), amount, 0);
        if (receiver) {
          return helper(receiver.status.offset(), -amount, steps);
        }
      }
    };
    prototype.trade = function(seller, buyer, isSelling, subjectName, options, callback){
      var ref$, defaultPrice, ref1$, validate, board, args, minimum, endTrading, inputFn, validateFn, callbackFn;
      ref$ = options != null
        ? options
        : {}, defaultPrice = (ref1$ = ref$.defaultPrice) != null ? ref1$ : 1, validate = ref$.validate;
      board = this;
      args = [].slice.call(arguments);
      minimum = 1;
      endTrading = function(){
        board.boardDiv.removeClass('trading');
        return board.reloadBusinessMenu();
      };
      inputFn = function(isFirst){
        var btns;
        if (isSelling) {
          btns = ["Â§ Demand", "Cancel"];
          if (isFirst) {
            btns = btns.concat("Let " + buyer.name + " offer a price");
          }
          return seller.input('number', btns, {
            text: seller.name.toUpperCase() + ": how much do you demand for " + subjectName + "?",
            'default': defaultPrice || 1,
            validate: validateFn,
            callback: callbackFn
          });
        } else {
          btns = ["Â§ Offer", "Cancel"];
          if (isFirst) {
            btns = btns.concat("Let " + seller.name + " demand a price");
          }
          return buyer.input('number', btns, {
            text: buyer.name.toUpperCase() + ": Enter your price offer for " + subjectName,
            'default': defaultPrice || 1,
            validate: validateFn,
            callback: callbackFn
          });
        }
      };
      validateFn = function(value){
        if (value > buyer.bits) {
          return "You don't even have " + plural(value, 'bit') + "!";
        } else if (value < minimum) {
          return "You have to pay at least " + plural(minimum, 'bit') + "!";
        } else if (typeof validate === 'function') {
          return validate(value);
        } else {
          return true;
        }
      };
      callbackFn = function(board, value, btn){
        var ref$;
        buyer.unhighlight();
        if (btn === 0) {
          if (isSelling) {
            buyer.highlight();
            return buyer.buttons(buyer.name.toUpperCase() + ": Do you want to buy " + subjectName + " from " + seller.name + " for " + plural(value, 'bit') + "?", (ref$ = {}, ref$["Yes, Buy for " + plural(value, 'bit')] = function(){
              buyer.giveBitsTo(seller, value);
              endTrading();
              return callback(value, seller, buyer);
            }, ref$["Counteroffer"] = function(){
              return buyer.input('number', ["Â§ Offer", "Cancel"], {
                text: buyer.name.toUpperCase() + ": How much do you offer for " + subjectName + "?",
                'default': defaultPrice || 1,
                validate: validateFn,
                callback: function(board, value2, btn2){
                  var minimum;
                  if (btn2 === 0) {
                    minimum = value2;
                    return helper();
                  } else {
                    return callbackFn(board, value, btn);
                  }
                }
              });
            }, ref$["Don't Buy"] = function(){
              options.defaultPrice >= value || (options.defaultPrice = value);
              return helper();
            }, ref$));
          } else {
            seller.highlight();
            return seller.buttons(seller.name.toUpperCase() + ": Do you want to sell " + subjectName + " to " + seller.name + " for " + plural(value, 'bit') + "?", (ref$ = {}, ref$["Yes, Sell for " + plural(value, 'bit')] = function(){
              buyer.giveBitsTo(seller, value);
              endTrading();
              return callback(value, seller, buyer);
            }, ref$["Don't Sell"] = function(){
              options.defaultPrice >= value || (options.defaultPrice = value);
              return helper();
            }, ref$));
          }
        } else if (btn === 1) {
          endTrading();
          return callback(false);
        } else {
          return inputFn(true);
        }
      };
      if (buyer == null || seller === buyer) {
        return board.selectPlayerForTrade(seller, function(otherPlayer){
          options.buyer = otherPlayer;
          buyer.highlight();
          board.uncloak();
          return inputFn(false);
        });
      } else {
        buyer.highlight();
        board.uncloak();
        return inputFn(false);
      }
    };
    prototype.tradeField = function(field, buyer, callback){
      var board, seller, creditorName, minPrice;
      callback == null && (callback = function(){});
      board = this;
      seller = field.owner;
      if (seller.owes) {
        if (seller.creditor) {
          creditorName = seller.creditor.name;
        } else {
          creditorName = "The Bank";
        }
        minPrice = field.price;
      } else {
        minPrice = 1;
      }
      return board.trade(field.owner, buyer, false, field.name, {
        defaultPrice: minPrice,
        validate: function(value){
          if (buyer.owes && value < field.price) {
            return "You have to pay at least " + plural(field.price, 'bit') + " to not cheat " + creditorName + "!";
          } else {
            return true;
          }
        }
      }, function(value, seller, buyer){
        if (value) {
          if (field.isMortgaged) {
            buyer.buttons("");
          } else {
            field.setHouses(0);
          }
          field.changeOwner(buyer);
        }
        return callback.apply(this, arguments);
      });
    };
    prototype.tradeCard = function(seller, buyer, isSelling, callback){
      var board;
      callback == null && (callback = function(){});
      board = this;
      return board.trade(seller, buyer, isSelling, "Return-From-the-Moon card", null, function(value){
        if (value) {
          seller.returnFromTheMoonCards--;
          buyer.returnFromTheMoonCards++;
        }
        return callback.apply(this, arguments);
      });
    };
    prototype._events = {
      error: [function(err){
        console.error(err.stack);
        console.error("---------------");
        throw err;
      }],
      newGame: [],
      nextTurn: [],
      playerLostGame: [],
      playerMoved: [],
      playerBitsChanged: [],
      buttons: []
    };
    constructor.fieldHeight = 126;
    constructor.fieldWidth = 72;
    constructor.fieldOffset = 774;
    constructor.boardWidth = 900;
    constructor.Board = constructor;
    constructor.nameDatalistID = "";
    return Board;
  }(MicroEvent.prototype));
  Monopony.Player = Player = (function(){
    Player.displayName = 'Player';
    var prototype = Player.prototype, constructor = Player;
    importAll$(prototype, arguments[0]);
    function Player(_board, arg$){
      var ref$, ref1$, avatar, Monopony, board, player, kickBtn, nameHasError, pos, scale, this$ = this instanceof ctor$ ? this : new ctor$;
      this$._board = _board;
      ref$ = arg$ != null
        ? arg$
        : {}, this$.name = ref$.name, this$.avatar = ref$.avatar, this$.color = ref$.color, this$.position = (ref1$ = ref$.position) != null ? ref1$ : 0, this$.id = ref$.id, this$.playerController = (ref1$ = ref$.playerController) != null ? ref1$ : "singleplayer", avatar = ref$.avatar;
      Monopony = this$._board.constructor;
      board = this$._board;
      player = this$;
      if (!board.setup) {
        player.bits = board.startBits;
      }
      player.lastPosition = this$.position;
      /*
      	player.id = data.id
      	if data.playerController
      		player.playerController = data.playerController
      */
      player.name == null && (player.name = Monopony.defaultNames.randomUnused(board.players, 'name') || "");
      if (!player.avatar) {
        player.image = player.statusImage = {
          attr: function(){}
        };
        if (!player.autoChangeAvatar()) {
          player.avatar = Monopony.defaultNames.random();
        }
      }
      player.color == null && (player.color = Monopony.defaultColors.randomUnused(board.players, 'color') || Monopony.defaultColors.random());
      player.status = $('<div>').addClass('statusBar-player').data('player', player).addClass(player.playerController).click(function(e){
        return player.trigger('playerClicked', e);
      });
      player.statusImage = $('<img>').addClass('statusBar-avatar').appendTo(player.status).click(function(){
        return board.showAvatarPicker(player);
      });
      kickBtn = $('<span>').addClass('statusBar-remove-player');
      if (player.playerController === 'singleplayer' || player.playerController === 'local') {
        if (board.setup) {
          nameHasError = false;
          player.statusName = $('<input>').val(player.name).attr('list', 'monopony_names_datalist').input(function(){
            var newName, errors;
            newName = this.value;
            player.rename(newName);
            player.autoChangeAvatar(newName);
            errors = board.checkForErrorneousNames(player);
            if (errors) {
              player.statusLocation.text(errors[0]);
              if (!nameHasError) {
                player.status.addClass('errorneousName');
                return nameHasError = true;
              }
            } else if (nameHasError) {
              player.status.removeClass('errorneousName');
              player.statusLocation.text("");
              return nameHasError = false;
            }
          });
        } else {
          player.statusName = $('<span>').text(player.name);
        }
        player.statusName.addClass('statusBar-playerName').appendTo(player.status);
        if (board.room) {
          kickBtn.text("leave");
        } else {
          kickBtn.text("remove");
        }
      } else {
        player.statusName = $('<span>').addClass('statusBar-playerName').text(player.name).appendTo(player.status);
        kickBtn.text("kick");
      }
      kickBtn.appendTo(player.status);
      player.statusBits = $('<div>').addClass('statusBar-bits').appendTo(player.status);
      player.statusLocation = $('<div>').addClass('statusBar-location').appendTo(player.status);
      if (board.players.length === 3) {
        board.boardDiv.removeClass('two-players');
      }
      /*nameChangeTimeout = null
      player.statusName.input ->
      	clearTimeout nameChangeTimeout
      	newName = @value
      	nameChangeTimeout = sleep 500ms, ->
      */
      kickBtn.click(function(e){
        var ref$, isOnlyLocal, i$, len$, player;
        if (!((ref$ = board.room) != null && ref$.isHost)) {
          board.log("[Error] only hosts can kick player");
          return;
        }
        if (board.multiplayer && player.playerController === 'local') {
          isOnlyLocal = true;
          for (i$ = 0, len$ = (ref$ = board.players).length; i$ < len$; ++i$) {
            player = ref$[i$];
            if (player !== player && player.playerController === 'local') {
              isOnlyLocal = false;
            }
          }
          if (isOnlyLocal) {
            return board.gotoLobby();
          }
        }
        if (board.players.length > 2 || board.multiplayer) {
          if (player.playerController === 'remote') {
            return board.socket.emit('kick', player.id);
          }
          board.removePlayer(player);
        }
        return false;
      });
      player.status.hide().insertBefore(board.newPlayerDiv).fadeIn('slow');
      pos = Monopony.spaces[player.position];
      scale = board.scale;
      player.image = $('<img>').addClass('player').css({
        left: pos.x * scale,
        top: pos.y * scale
      }).appendTo($('<div>').addClass('position-wrapper').appendTo(board.boardDiv));
      player.changeAvatar(player.avatar);
      player.draw(function(){}, true);
      return this$;
    } function ctor$(){} ctor$.prototype = prototype;
    prototype._board = null;
    prototype.id = null;
    prototype.name = "";
    prototype.avatar = "";
    prototype.position = 0;
    prototype.lastPosition = 0;
    prototype.bits = 0;
    prototype.playerController = 'singleplayer';
    prototype.returnFromTheMoonCards = 0;
    prototype.doubles = 0;
    prototype.color = null;
    prototype.avatarIsCustom = false;
    prototype.isParking = false;
    prototype.isOnTheMoon = false;
    prototype.lost = false;
    prototype.status = null;
    prototype.statusName = null;
    prototype.statusBits = null;
    prototype.statusLocation = null;
    prototype.statusImage = null;
    prototype.image = null;
    prototype.remote = false;
    prototype.getTotalAssets = function(){
      var player, assets, i$, ref$, len$, field;
      player = this;
      assets = player.bits;
      for (i$ = 0, len$ = (ref$ = board.fields).length; i$ < len$; ++i$) {
        field = ref$[i$];
        if (field.owner === player) {
          assets += field.calcValue();
        }
      }
      return assets;
    };
    prototype.draw = function(callback, moveDirectly){
      var board, player, scale, pos, animatePlayer, animatePlayerToEdge, side, sideOld, speed, posEdge;
      board = this._board;
      player = this;
      callback || (callback = function(){
        board.update();
        return player.processField();
      });
      scale = board.scale;
      pos = Monopony.spaces[player.position];
      if (player.position === 10) {
        if (player.isOnTheMoon) {
          pos.x += 30;
          pos.y += -30;
        } else {
          pos.x += -10;
          pos.y += 5;
        }
      }
      animatePlayer = function(easing, speed_){
        speed_ == null && (speed_ = speed);
        return player.image.animate({
          left: pos.x * scale,
          top: pos.y * scale
        }, board.animationspeed * speed_, easing, function(){
          return callback(board, player);
        });
      };
      animatePlayerToEdge = function(easing, speed_){
        speed_ == null && (speed_ = speed);
        return player.image.animate({
          left: posEdge.x * scale,
          top: posEdge.y * scale
        }, board.animationspeed * speed_, easing);
      };
      player.image.stop();
      side = Math.floor(player.position / 10);
      sideOld = Math.floor(player.lastPosition / 10);
      if (side === sideOld) {
        speed = player.position - player.lastPosition;
        if (speed < 0) {
          speed += 40;
        }
        return animatePlayer('swing');
      } else if (moveDirectly) {
        return animatePlayer('swing', 14);
      } else {
        sideOld++;
        sideOld %= 4;
        posEdge = Monopony.spaces[sideOld * 10];
        speed = sideOld * 10 - player.lastPosition;
        if (speed < 0) {
          speed += 40;
        }
        animatePlayerToEdge('easeInQuad');
        while (sideOld !== side) {
          sideOld++;
          sideOld %= 4;
          posEdge = Monopony.spaces[sideOld * 10];
          animatePlayerToEdge('linear', 10);
        }
        speed = player.position - sideOld * 10;
        if (speed < 0) {
          speed += 40;
        }
        return animatePlayer('easeOutQuad');
      }
    };
    prototype.remove = function(noAnimation){
      return board.removePlayer(this, noAnimation);
    };
    prototype.reset = function(){
      return importAll$(this, {
        position: 0,
        lastPosition: 0,
        bits: board.startBits,
        assets: 0,
        isParking: false,
        onTheMoon: false,
        lost: false
      });
    };
    prototype.cleanUp = function(){
      var player, board;
      player = this;
      board = this._board;
      player.bits = board.startBits;
      player.isParking = false;
      player.isOnTheMoon = false;
      player.lost = false;
      player.returnFromTheMoonCards = 0;
      player.position = 0;
      player.lastPosition = 0;
      player.status.removeClass("gameover");
      return player.image.removeClass("gameover");
    };
    prototype.rename = function(newName){
      var player;
      player = this;
      if (newName !== player.name) {
        player.name = newName;
        if (board.multiplayer) {
          if (player.id === board.id) {
            return board.socket.emit('changeName', player.name);
          } else {
            return player.statusName.text(player.name);
          }
        }
      }
    };
    prototype.autoChangeAvatar = function(){
      var board, player, newAvatar, i$, ref$, len$, otherAvatar, otherAvatarLC;
      board = this._board;
      player = this;
      newAvatar = player.name.toLowerCase().replace(/ /g, "_").replace(/\s+/g, " ").replace(/^Prince(ss)? /, "");
      for (i$ = 0, len$ = (ref$ = Monopony.defaultNames).length; i$ < len$; ++i$) {
        otherAvatar = ref$[i$];
        otherAvatarLC = otherAvatar.toLowerCase();
        if (newAvatar === otherAvatarLC || newAvatar.length === 3 && newAvatar === otherAvatarLC.substr(0, 3) || newAvatar === otherAvatarLC.replace(/ .*/, "") || newAvatar === otherAvatarLC.replace(/ /g, "_") || newAvatar === otherAvatarLC.replace(/ /g, "")) {
          player.changeAvatar(otherAvatar);
          return true;
        }
      }
      return false;
    };
    prototype.changeAvatar = function(newAvatar, isUrl){
      var Monopony, board, player, path;
      Monopony = this._board.constructor;
      board = this._board;
      player = this;
      if (!isUrl) {
        if (!in$(newAvatar, Monopony.defaultNames)) {
          console.warn("[!change Avatar] unknown avatar", newAvatar);
          return false;
        }
        path = Monopony.getAvatarUrl(newAvatar);
        player.avatarIsCustom = false;
      } else {
        path = newAvatar;
        player.avatarIsCustom = true;
      }
      player.avatar = newAvatar;
      player.image.attr('src', path);
      player.statusImage.attr('src', path);
      return player.trigger('avatarChanged', board, newAvatar);
    };
    prototype.highlight = function(){
      var board, player;
      board = this._board;
      player = this;
      if (board.highlightedPlayer != null && board.highlightedPlayer !== player) {
        board.highlightedPlayer.unhighlight();
      }
      board.boardDiv.addClass('highlighting-player');
      board.highlightedPlayer = player;
      return player.status.addClass('highlight');
    };
    prototype.unhighlight = function(){
      var board, player;
      board = this._board;
      player = this;
      if (board.highlightedPlayer === player) {
        board.boardDiv.removeClass('highlighting-player');
        player.status.removeClass('highlight');
        return board.highlightedPlayer = null;
      }
    };
    prototype.gameover = function(callback){
      var board, player;
      callback == null && (callback = function(){});
      board = this._board;
      player = this;
      player.lost = true;
      board.players.removeItem(player);
      board.bankruptPlayers.push(player);
      player.status.addClass('gameover');
      player.image.addClass('gameover');
      player.trigger('gameover', board);
      player.statusBits.text(plural(0, 'bit') + "");
      player.statusLocation.text("game over");
      if (board.players.length === 1) {
        return board.gameEnd();
      } else {
        return callback();
      }
    };
    prototype.moveTo = function(newPos, callback){
      var board, player;
      newPos == null && (newPos = 0);
      board = this._board;
      player = this;
      if (player.position < newPos) {
        return player.move(newPos - player.position, callback);
      } else {
        return player.move(board.fields.length - player.position + newPos, callback);
      }
    };
    prototype.moveDirectlyTo = function(newPos, callback){
      var player;
      newPos == null && (newPos = 0);
      player = this;
      if (player.isOnTheMoon && newPos !== 10) {
        debugLog("Player " + player.name + " moved whilst being on the Moon.", player);
        board.log;
        player.isOnTheMoon = 0;
      }
      player.lastPosition = player.position;
      player.position = newPos;
      return player.draw(callback, true);
    };
    prototype.move = function(i, callback){
      var player, board, oldPosition, ref$;
      i == null && (i = 1);
      player = this;
      board = this._board;
      player.lastPosition = oldPosition = player.position;
      player.position += i;
      if (player.position < 0) {
        player.position = ((player.position) % (ref$ = board.fields.length) + ref$) % ref$;
      }
      if (player.isOnTheMoon) {
        player.isOnTheMoon = 0;
      }
      if (player.position >= board.fields.length) {
        player.position -= board.fields.length;
        player.receiveBits(200);
        board.log(player.name + " recieved 200 bits for passing GO!");
      }
      return player.draw(callback);
    };
    prototype.pay = function(amount, callback){
      var player, board;
      callback == null && (callback = function(){});
      player = this;
      board = this._board;
      if (!amount) {
        return;
      }
      if (player.bits < amount) {
        /*
        board.msgBox """
        	#{player.name} ran out of money.
        	Game over, buddy.
        	Note: taking loans from the bank by mortaging properties is currently not implemented, sorry
        """
        player.gameover!
        */
        player.owes = amount;
        player.creditor = null;
        board.msgBox(player.name + " doesn't have enough bits and needs to sell houses and/or mortgage properties.");
        return board.openBusinessMenu(amount, function(){
          callback();
        });
      } else {
        player.bits -= amount;
        player.trigger('bitsChanged', board, player, -amount);
        board.ui('bits', player, -amount);
        board.update();
        return callback();
      }
    };
    prototype.receiveBits = function(amount){
      var board, player;
      board = this._board;
      player = this;
      if (!amount) {
        return;
      }
      player.bits += amount;
      player.trigger('bitsChanged', board, this, amount);
      board.ui('bits', player, amount);
      return board.update();
    };
    prototype.giveBitsTo = function(receiver, amount, callback){
      var board, player;
      callback == null && (callback = function(){});
      board = this._board;
      player = this;
      if (!amount) {
        return;
      }
      receiver = board.getPlayer(receiver);
      if (!receiver) {
        throw new TypeError("in .giveBitsTo: unknown receiver");
      }
      if (player.bits < amount) {
        /*
        board.msgBox """
        	#{player.name} ran out of money.
        	Game over, buddy.
        	Note: taking loans from the bank by mortaging properties is currently not implemented, sorry
        """
        player.gameover!
        */
        board.msgBox(player.name + " doesn't have enough bits and needs to sell houses and/or mortgage properties.");
        player.owes = amount;
        player.creditor = receiver;
        return board.openBusinessMenu(amount, function(lastBits){
          if (lastBits >= amount) {
            return player.giveBitsTo(receiver, amount, callback);
          } else {
            return callback();
          }
        });
      } else {
        player.bits -= amount;
        receiver.bits += amount;
        board.ui('bits', player, -amount, receiver);
        board.update();
        return callback();
      }
    };
    prototype.toTheMoon = function(){
      var board, player;
      board = this._board;
      player = this;
      player.doubles = 0;
      board.boardDiv.addClass('to-the-MOOOOOOOONAAAAAAAA');
      return sleep(4000, function(){
        board.boardDiv.removeClass('to-the-MOOOOOOOONAAAAAAAA');
        board.log(player.name + " was sent to the moon");
        player.isOnTheMoon = 1;
        return player.moveDirectlyTo(10, function(){
          return board.endTurn();
        });
      });
    };
    prototype.buttons = function(btns, callback){
      var board, player;
      board = this._board;
      player = this;
      return Monopony.playerController[player.playerController].buttons(board, btns, callback);
    };
    prototype.msgBox = function(text, callback){
      var board, player;
      board = this._board;
      player = this;
      return Monopony.playerController[player.playerController].msgBox(board, text, callback);
    };
    prototype.input = function(type, btns, options){
      var board, player;
      board = this._board;
      player = this;
      return Monopony.playerController[player.playerController].input(board, type, btns, options);
    };
    prototype.rollDice = function(callback){
      return Monopony.playerController[player.playerController].rollDice(board, callback);
    };
    prototype.processField = function(){
      var board, player, field, btnHasNotEnoughBits, ref$, utilityRent, stationRent, rent;
      board = this._board;
      player = this;
      field = board.fields[player.position];
      board.log(player.name + " landed on " + field.name + ".");
      if (field.buyable) {
        if (!field.owner) {
          btnHasNotEnoughBits = field.price > player.bits ? "%" : "";
          if (btnHasNotEnoughBits) {
            board.log(field.name + " has no owner, but sadly " + player.name + " has NOT enough bits to buy it. It costs " + plural(field.price, 'bit') + ".");
          } else {
            board.log(field.name + " has no owner, " + player.name + " may buy it for " + plural(field.price, 'bit') + ".");
          }
          return player.buttons((ref$ = {}, ref$[btnHasNotEnoughBits + " Buy Property"] = function(){
            board.log("*" + player.name + " buys " + field.name + "*");
            field.buy(player);
            return board.endTurn();
          }, ref$["Auction"] = function(){
            return board.auctionField(field, function(){
              return board.endTurn();
            });
          }, ref$));
        } else if (field.owner === player) {
          board.log("" + field.name + " belongs to " + field.owner.name + ".\n" + player.name + " is just passing through.");
          return board.endTurn();
        } else if (field.isMortgaged) {
          board.log("" + field.name + " is currently mortgaged, thus no rent has to be paid.\n" + player.name + " is just passing through.");
          return board.endTurn();
        } else {
          if (field.utility) {
            if (field.owner === (ref$ = board.fields[12].owner) && ref$ === board.fields[28].owner) {
              utilityRent = board.currentDice.sum * 10;
              board.log("" + field.owner.name + " owns Apple Harvest and Weather Station.\n" + player.name + " has to pay " + field.owner.name + " " + plural(utilityRent, 'bit') + " (10 bits \u00D7 sum of dice).");
              return board.buttons("Pay " + plural(utilityRent, 'bit'), function(){
                console.log("*" + player.name + " pays " + field.owner.name + "*");
                return player.giveBitsTo(field.owner, utilityRent, function(){
                  return board.endTurn();
                });
              });
            } else {
              utilityRent = board.currentDice.sum * 4;
              board.log(player.name + " has to pay " + field.owner.name + " " + plural(utilityRent, 'bit') + " (4 bits \u00D7 sum of dice).");
              return board.buttons("Pay " + plural(utilityRent, 'bit'), function(){
                console.log("*" + player.name + " pays " + field.owner.name + "*");
                return player.giveBitsTo(field.owner, utilityRent, function(){
                  return board.endTurn();
                });
              });
            }
          } else if (field.station) {
            stationRent = field.calcRent();
            board.log(player.name + " has to pay " + field.owner.name + " " + plural(stationRent, 'bit') + ".");
            return board.buttons("Pay " + plural(stationRent, 'bit'), function(){
              console.log("*" + player.name + " pays " + field.owner.name + "*");
              return player.giveBitsTo(field.owner, stationRent, function(){
                return board.endTurn();
              });
            });
          } else {
            rent = field.calcRent();
            board.log("" + field.name + " belongs to " + field.owner.name + "\n" + player.name + " has to pay " + field.owner.name + " " + plural(rent, 'bit'));
            return board.buttons("Pay " + plural(rent, 'bit'), function(){
              console.log("*" + player.name + " pays " + field.owner.name + "*");
              return field.payRent(player, function(){
                return board.endTurn();
              });
            });
          }
        }
      } else {
        return field.action(board, player, field);
      }
    };
    prototype.drawCard = function(deck){
      var player, board, deckObj, card, hideCardCallback;
      player = this;
      board = player._board;
      deckObj = board[deck + "Cards"];
      card = deckObj.shift();
      hideCardCallback = function(){
        if (card.callback) {
          return card.callback(board, player, card);
        } else {
          return board.endTurn();
        }
      };
      if (!card.returnFromTheMoon) {
        board.cardButton.text("continue").one('click', function(){
          if (deckObj.length === 0) {
            board.log("The card deck got refilled and shuffled");
            board.shuffleDeck(deck);
            board.ui('hideCard', deck, card, function(){
              board.ui('updateCarddeck', deck);
              return hideCardCallback();
            });
          } else {
            board.ui('hideCard', deck, card, hideCardCallback);
          }
          if (card.bits > 0) {
            player.receiveBits(card.bits);
          } else if (card.bits < 0) {
            player.pay(-card.bits);
          }
        });
      } else {
        board.cardButton.text("save for later").one('click', function(){
          player.returnFromTheMoonCards++;
          return board.ui('hideCard', deck, card, hideCardCallback);
        });
      }
      return board.ui('drawCard', deck, card);
    };
    prototype._events = {
      error: [function(err){
        err.message = "error on player " + this.name + " -  " + err.message;
        return this._board.trigger('error', board, this, err);
      }],
      lose: [function(player){
        return this._board.trigger('playerLostGame', board, this);
      }],
      bitsChanged: [function(board, player, amount){
        return board.trigger('playerBitsChanged', board, player, amount);
      }],
      avatarChanged: [],
      playerClicked: [function(event){
        var player, board;
        player = this;
        board = player._board;
        return board.trigger('playerClicked', player, event);
      }]
    };
    return Player;
  }(MicroEvent.prototype));
  Monopony.Field = Field = (function(){
    Field.displayName = 'Field';
    var prototype = Field.prototype, constructor = Field;
    function Field(){
      var this$ = this instanceof ctor$ ? this : new ctor$;
      return this$;
    } function ctor$(){} ctor$.prototype = prototype;
    prototype._board = null;
    prototype.name = "";
    prototype.index = 0;
    prototype.buyable = false;
    prototype.utility = false;
    prototype.station = false;
    prototype.cleanUp = function(){
      var field, ref$;
      field = this;
      if (field.buyable) {
        if ((ref$ = field.ownershipTokenWrapper) != null) {
          ref$.remove();
        }
        field.houses = 0;
        field.isMortgaged = false;
        return field.owner = null;
      }
    };
    prototype.getPos = function(){
      var board, field, h, w, o, f;
      board = this._board;
      field = this;
      h = Monopony.fieldHeight, w = Monopony.fieldWidth, o = Monopony.fieldOffset;
      f = field.index;
      switch (f) {
      case 0:
        return [o, o, h, h];
      case 10:
        return [0, o, h, h];
      case 20:
        return [0, 0, h, h];
      case 30:
        return [o, 0, h, h];
      default:
        switch (Math.floor(f / 10)) {
        case 0:
          return [o - f * w, o, w, h];
        case 1:
          return [0, o - (f - 10) * w, h, w];
        case 2:
          return [(f - 21) * w + h, 0, w, h];
        case 3:
          return [o, o - (40 - f) * w, h, w];
        }
      }
    };
    prototype.reveal = function(){
      var board, field, pos;
      board = this._board;
      field = this;
      pos = field.getPos();
      return board.cloak(pos[0], pos[1], pos[2], pos[3]);
    };
    return Field;
  }());
  Monopony.ActionField = ActionField = (function(superclass){
    var prototype = extend$((import$(ActionField, superclass).displayName = 'ActionField', ActionField), superclass).prototype, constructor = ActionField;
    function ActionField(arg$){
      var ref$, this$ = this instanceof ctor$ ? this : new ctor$;
      this$.name = arg$.name, this$.action = (ref$ = arg$.action) != null
        ? ref$
        : function(){}, this$.data = arg$.data;
      return this$;
    } function ctor$(){} ctor$.prototype = prototype;
    prototype.action = null;
    prototype.data = null;
    prototype.group = 'action';
    return ActionField;
  }(Monopony.Field));
  Monopony.UtilityField = UtilityField = (function(superclass){
    var prototype = extend$((import$(UtilityField, superclass).displayName = 'UtilityField', UtilityField), superclass).prototype, constructor = UtilityField;
    function UtilityField(arg$){
      var ref$, this$ = this instanceof ctor$ ? this : new ctor$;
      this$.name = arg$.name, this$.price = (ref$ = arg$.price) != null
        ? ref$
        : this$.price;
      return this$;
    } function ctor$(){} ctor$.prototype = prototype;
    prototype.buyable = true;
    prototype.utility = true;
    prototype.owner = null;
    prototype.price = 0;
    prototype.group = 'utility';
    prototype.houses = 0;
    prototype.calcValue = function(){
      var field;
      field = this;
      if (field.isMortgaged) {
        return field.price / 2 * 1.1;
      } else {
        return field.price;
      }
    };
    prototype.calcRent = function(){
      var field;
      field = this;
      if (field.isMortgaged) {
        return 0;
      } else {
        return field.price;
      }
    };
    prototype.isGroupComplete = function(){
      var field, player, i$, ref$, len$, otherField;
      field = this;
      player = field.owner;
      for (i$ = 0, len$ = (ref$ = board.fieldGroups[field.group]).length; i$ < len$; ++i$) {
        otherField = ref$[i$];
        if (otherField.owner !== player) {
          return false;
        }
      }
      return true;
    };
    prototype.calcPriceForHouses = function(amount, fieldMap){
      var field, player, playerOwnsGroup, price, i$, ref$, len$, otherField, key$, maxHouses, minHouses, houses, housesSansMortgage;
      fieldMap = clone$(fieldMap);
      field = this;
      player = this.owner;
      if (!(-1 <= amount && amount <= Monopony.stringMaps.houses_.length - 1)) {
        return false;
      }
      playerOwnsGroup = field.isGroupComplete();
      if (!playerOwnsGroup) {
        if (amount > 0) {
          return false;
        }
        price = 0;
        fieldMap[field.index] = amount;
        for (i$ = 0, len$ = (ref$ = board.fieldGroups[field.group]).length; i$ < len$; ++i$) {
          otherField = ref$[i$];
          if (field.owner === player) {
            fieldMap[key$ = otherField.index] == null && (fieldMap[key$] = otherField.houses);
            if (amount === -1 && !otherField.isMortgaged) {
              price -= otherField.price / 2;
            } else if (amount === 0 && otherField.isMortgaged) {
              price += otherField.price / 2 * 1.1;
            }
          }
        }
      } else {
        fieldMap[field.index] = amount;
        price = 0;
        maxHouses = amount + 1;
        minHouses = amount - 1;
        if (amount === -1) {
          maxHouses++;
        }
        if (amount === 1) {
          minHouses--;
        }
        for (i$ = 0, len$ = (ref$ = board.fieldGroups[field.group]).length; i$ < len$; ++i$) {
          otherField = ref$[i$];
          houses = fieldMap[otherField.index] || otherField.houses;
          if (!(maxHouses >= houses && houses >= minHouses)) {
            if (houses > maxHouses) {
              houses = maxHouses;
            } else if (houses < minHouses) {
              houses = minHouses;
            }
          }
          housesSansMortgage = houses;
          if (houses === -1 && otherField.houses !== -1) {
            price -= otherField.price / 2;
            housesSansMortgage++;
          } else if (otherField.houses === -1 && houses !== -1) {
            price += otherField.price / 2 * 1.1;
            housesSansMortgage--;
          }
          if (otherField.houses < housesSansMortgage) {
            price += (housesSansMortgage - otherField.houses) * otherField.housePrice;
          } else if (otherField.houses > housesSansMortgage) {
            price -= (otherField.houses - housesSansMortgage) * otherField.housePrice / 2;
          }
          fieldMap[otherField.index] = houses;
        }
      }
      return [price, fieldMap];
    };
    prototype.buy = function(player, payPrincipal){
      var field, board, price, ref$, side, x, y, dir;
      field = this;
      board = this._board;
      price = field.price;
      if (field.isMortgaged) {
        price *= 1.1;
        if (payPrincipal == null) {
          board.log("" + player.name + " may pay the principal to de-mortgage the property\nnote: de-mortgaging the property later will require an additional pay of 10% interest!");
          board.buttons((ref$ = {}, ref$["pay principal (total cost: " + plural(price + field.mortgage, 'bit') + ")"] = function(){
            return field.buy(player, true);
          }, ref$["don't pay principal"] = function(){
            return field.buy(player, false);
          }, ref$));
          return;
        } else if (payPrincipal) {
          price += field.mortgage;
          field.isMortgaged = false;
        }
      }
      if (player.bits >= price) {
        player.pay(price);
        field.owner = player;
        side = Math.floor(field.index * 4 / board.fields.length);
        switch (side) {
        case 0:
          x = 7;
          y = 71;
          dir = 'horizontal';
          break;
        case 1:
          x = -30;
          y = 12;
          dir = 'vertical';
          break;
        case 2:
          x = 5;
          y = -34;
          dir = 'horizontal';
          break;
        case 3:
          x = 73;
          y = 13;
          dir = 'vertical';
        }
        field.ownershipTokenWrapper = $('<div>').addClass('ownershipToken-wrapper').append(field.ownershipToken = $('<div>').addClass('ownershipToken').addClass("ownershipToken-" + dir).css({
          left: Monopony.spaces[field.index].x + x,
          top: Monopony.spaces[field.index].y + y,
          background: player.color
        })).appendTo(board.ownershipTokenContainer);
        return true;
      } else {
        board.log(player.name + " does NOT have enough bits to buy this property.");
        return false;
      }
    };
    prototype.changeOwner = function(newOwner){
      var field;
      field = this;
      field.owner = newOwner;
      if (newOwner) {
        return field.ownershipToken.css('background', newOwner.color);
      } else {
        return field.ownershipTokenWrapper.remove();
      }
    };
    return UtilityField;
  }(Monopony.Field));
  Monopony.BuyableField = BuyableField = (function(superclass){
    var prototype = extend$((import$(BuyableField, superclass).displayName = 'BuyableField', BuyableField), superclass).prototype, constructor = BuyableField;
    function BuyableField(arg$){
      var this$ = this instanceof ctor$ ? this : new ctor$;
      this$.name = arg$.name, this$.group = arg$.group, this$.price = arg$.price, this$.rent = arg$.rent, this$.house1 = arg$.house1, this$.house2 = arg$.house2, this$.house3 = arg$.house3, this$.house4 = arg$.house4, this$.hotel = arg$.hotel, this$.housePrice = arg$.housePrice;
      return this$;
    } function ctor$(){} ctor$.prototype = prototype;
    prototype.buyable = true;
    prototype.utility = false;
    prototype.owner = null;
    prototype.group = "";
    prototype.isMortgaged = false;
    prototype.group = null;
    prototype.ownershipToken = null;
    prototype.ownershipTokenWrapper = null;
    prototype.price = 0;
    prototype.rent = 0;
    prototype.house1 = 0;
    prototype.house2 = 0;
    prototype.house3 = 0;
    prototype.house4 = 0;
    prototype.hotel = 0;
    prototype.housePrice = 0;
    prototype.calcValue = function(){
      var field;
      field = this;
      return superclass.prototype.calcValue.call(this) + field.houses * field.housePrice;
    };
    prototype.calcRent = function(){
      var field, board, ref$, i$, len$, otherField;
      field = this;
      board = this._board;
      if (field.isMortgaged) {
        return 0;
      }
      if (field.houses === 5) {
        return field.hotel;
      } else if (1 <= (ref$ = field.houses) && ref$ <= 4) {
        return field["house" + field.houses];
      } else {
        for (i$ = 0, len$ = (ref$ = board.fieldGroups[field.group]).length; i$ < len$; ++i$) {
          otherField = ref$[i$];
          if (otherField.owner !== field.owner) {
            return field.rent;
          }
        }
        return field.rent * 2;
      }
    };
    prototype.update = function(){
      var field;
      field = this;
      return field.ownershipToken.text(Monopony.stringMaps.housesShort(field.houses));
    };
    prototype.payRent = function(player, callback){
      var field;
      field = this;
      if (!field.isMortgaged) {
        return player.giveBitsTo(field.owner, field.calcRent(), callback);
      }
    };
    prototype.setHouses = function(amount, fieldMapIn){
      var field, player, that, price, fieldMap, index, houses, x$;
      fieldMapIn == null && (fieldMapIn = {});
      field = this;
      player = this.owner;
      if (that = field.calcPriceForHouses(amount, fieldMapIn)) {
        price = that[0], fieldMap = that[1];
        console.log("[setH]", fieldMapIn, fieldMap);
      } else {
        return false;
      }
      if (player.bits >= price) {
        player.pay(price);
        for (index in fieldMap) {
          houses = fieldMap[index];
          if (board.fields[index].owner === player) {
            board.fields[index].houses = houses;
            if (houses === -1) {
              x$ = board.fields[index];
              x$.isMortgaged = true;
              x$.ownershipToken.addClass('mortgaged');
            }
            board.fields[index].update();
          }
        }
        return true;
      } else {
        board.log(player.name + " does NOT have enough bits to upgrade this property.");
        return false;
      }
    };
    prototype.mortgageField = function(callback){
      var field, player;
      callback == null && (callback = function(){});
      field = this;
      player = this.owner;
      if (field.isMortgaged) {
        throw "Can't morgage a property that is already mortgaged!";
      }
      board.log("" + player.name + " mortgaged " + field.name + ".\nThe Bank pays " + player.name + " " + plural(field.price, 'bit') + ".");
      return field.setHouses(-1);
    };
    prototype.repayMortgage = function(){
      var field, player, price;
      field = this;
      player = this.owner;
      price = field.price / 2 * 1.1;
      board.log("" + player.name + " pays the Bank " + plural(price, 'bit') + " to repay the mortgage for " + field.name + ".\nThe price includes the 10% interest rate " + player.name + " has to pay the Bank.");
      if (player.bits >= price) {
        player.pay(price);
        field.isMortgaged = false;
        return field.ownershipToken.removeClass('mortgaged');
      } else {
        board.log(player.name + " does NOT have enough bits to repay the mortgage for this property.");
        return false;
      }
    };
    return BuyableField;
  }(Monopony.UtilityField));
  Monopony.StationField = StationField = (function(superclass){
    var prototype = extend$((import$(StationField, superclass).displayName = 'StationField', StationField), superclass).prototype, constructor = StationField;
    function StationField(arg$){
      var ref$, this$ = this instanceof ctor$ ? this : new ctor$;
      this$.name = arg$.name, this$.price = (ref$ = arg$.price) != null ? ref$ : 0;
      return this$;
    } function ctor$(){} ctor$.prototype = prototype;
    prototype.utility = false;
    prototype.station = true;
    prototype.group = 'station';
    prototype.buy = Monopony.BuyableField.prototype.buy;
    prototype.calcRent = function(){
      var stationCounter;
      stationCounter = (field.owner === board.fields[5].owner) + (field.owner === board.fields[15].owner) + (field.owner === board.fields[25].owner) + (field.owner === board.fields[35].owner);
      return (function(){
        switch (stationCounter) {
        case 1:
          return 25;
        case 2:
          return 50;
        case 3:
          return 100;
        case 4:
          return 200;
        default:
          return 25 * Math.pow(2, stationCounter);
        }
      }());
    };
    Object.defineProperty(prototype, 'price', {
      get: function(){
        return this.calcRent.apply(this, arguments);
      },
      configurable: true,
      enumerable: true
    });
    return StationField;
  }(Monopony.UtilityField));
  Monopony.FieldMenu = FieldMenu = (function(){
    FieldMenu.displayName = 'FieldMenu';
    var prototype = FieldMenu.prototype, constructor = FieldMenu;
    function FieldMenu(field, player, highlight){
      var menu, board, isInDept, isOwned, groupIncomplete, x$, ref$, this$ = this instanceof ctor$ ? this : new ctor$;
      this$.field = field;
      this$.player = player;
      menu = this$;
      board = field._board;
      this$._board = board;
      isInDept = player.owes;
      isOwned = field.owner === player;
      groupIncomplete = !isOwned || field.utility || !field.isGroupComplete();
      menu.div = $("<div class='business-field-menu\n				" + (isOwned ? 'business-field-owned' : 'business-field-unowned') + "\n				" + (highlight ? 'business-field-highlighted' : '') + "\n				" + (groupIncomplete ? 'business-field-group-uncomplete' : '') + "\n				'>\n	<div class='business-field-icon'></div>\n	<div class='business-field-name'></div>\n	<div class='business-field-owner'></div>\n	" + (isOwned ? '<div class=\'business-field-slider-wrapper\'>\n	<div class=\'business-field-slider\'>\n		<div class=\'business-field-slider-thumb\'></div>\n	</div>\n	<div class=\'business-field-slider-label business-field-slider-label-house\'>hotel</div>\n	<div class=\'business-field-slider-label business-field-slider-label-house\'>4 houses</div>\n	<div class=\'business-field-slider-label business-field-slider-label-house\'>3 houses</div>\n	<div class=\'business-field-slider-label business-field-slider-label-house\'>2 houses</div>\n	<div class=\'business-field-slider-label business-field-slider-label-house\'>1 house</div>\n	<div class=\'business-field-slider-label\'>no houses</div>\n	<div class=\'business-field-slider-label\'>mortgaged</div>\n</div>' : '') + "\n	" + (field.owner ? '<button class=\'business-field-trade-btn\'>Trade</button>' : '') + "\n</div>");
      importAll$(menu, {
        icon: menu.div.find('.business-field-icon'),
        owner: menu.div.find('.business-field-owner'),
        sliderThumb: menu.div.find('.business-field-slider-thumb'),
        sliderCurrent: field.houses,
        sliderNewVal: field.houses,
        sliderMax: groupIncomplete ? 0 : 5
      });
      x$ = menu;
      x$.icon.addClass("business-field-icon-" + field.houses);
      x$.owner.text(((ref$ = field.owner) != null ? ref$.name : void 8) || "unowned");
      x$.div.find('.business-field-name').text(field.name);
      x$.div.find('.business-field-trade-btn').click(function(){
        var tradeBtn, posLeft, i$, ref$, otherMenu;
        tradeBtn = $(this);
        posLeft = menu.div.position().left;
        for (i$ in ref$ = board.businessMenus) {
          otherMenu = ref$[i$];
          otherMenu.div.css({
            left: otherMenu.div.position().left
          });
        }
        board.boardDiv.addClass('trading-fields');
        for (i$ in ref$ = board.businessMenus) {
          otherMenu = ref$[i$];
          if (otherMenu !== menu) {
            otherMenu.div.fadeOut();
          }
        }
        menu.div.animate({
          left: 58
        }, 'slow');
        tradeBtn.fadeOut();
        return board.tradeField(field, player, function(){
          var i$, ref$, otherMenu;
          for (i$ in ref$ = board.businessMenus) {
            otherMenu = ref$[i$];
            if (otherMenu !== menu) {
              otherMenu.div.fadeIn;
            }
          }
          return menu.div.animate({
            left: posLeft
          }, 'slow', function(){
            return board.boardDiv.removeClass('trading-fields');
          });
        });
      });
      menu.update();
      menu.sliderThumb.bind('mousedown', function(e){
        menu.mousedown(menu, e);
        console.log("[mousedown]", menu, field);
        return e.preventDefault();
      });
      menu.div.appendTo(board.businessMenu);
      return this$;
    } function ctor$(){} ctor$.prototype = prototype;
    prototype.field = null;
    prototype.player = null;
    prototype.sliderStartY = null;
    prototype.sliderCurrent = null;
    prototype.sliderLineheight = 20;
    prototype.sliderMax = 5;
    prototype.sliderThumb = null;
    prototype.sliderBits = 0;
    prototype.msg = null;
    prototype.bitsMsg = null;
    prototype.btn = null;
    prototype.remove = function(){
      var menu, field, board;
      menu = this;
      field = this.field;
      board = field._board;
      if (board.sliderSlidin === menu) {
        board.sliderSlidin = null;
      }
      menu.div.fadeOut(function(){
        return $(this).remove();
      });
      return delete board.businessMenus[field.index];
    };
    prototype.update = function(){
      var menu;
      menu = this;
      return menu.sliderThumb.css('top', 0 - (menu.sliderNewVal + 2) * menu.sliderLineheight);
    };
    prototype.mousedown = function(menu, e){
      var board;
      board = this.field._board;
      menu.sliderStartY = e.pageY;
      menu.sliderNewVal = menu.sliderCurrent;
      board.sliderSlidin = menu;
      return constructor.mousemove(board, e);
    };
    constructor.mouseup = function(board, e){
      var menu, fieldIndex, ref$, otherMenu;
      menu = board.sliderSlidin;
      if (!board.sliderSlidin) {
        return;
      }
      for (fieldIndex in ref$ = board.businessMenus) {
        otherMenu = ref$[fieldIndex];
        otherMenu.sliderCurrent = otherMenu.sliderNewVal;
      }
      return board.sliderSlidin = null;
    };
    constructor.mousemove = function(board, e){
      var menu, field, oldNewVal, ref$, ref1$, ref2$, ref3$, noChange, index, houses, that, price, btnText, fieldIndex, x$, results$ = [];
      if (!board.sliderSlidin) {
        return;
      }
      menu = board.sliderSlidin;
      field = menu.field;
      oldNewVal = menu.sliderNewVal;
      menu.sliderNewVal = menu.sliderCurrent - Math.floor((e.pageY - menu.sliderStartY) / menu.sliderLineheight);
      menu.sliderNewVal = (ref$ = (ref2$ = -1) > (ref3$ = menu.sliderNewVal) ? ref2$ : ref3$) < (ref1$ = menu.sliderMax) ? ref$ : ref1$;
      if (menu.sliderNewVal === field.houses) {
        noChange = true;
        for (index in ref$ = board.sliderFieldMap) {
          houses = ref$[index];
          if (menu.field.index !== index) {
            if (board.fields[index].houses !== houses) {
              noChange = false;
              break;
            }
          }
        }
        if (noChange) {
          player.buttons({
            $noAnimation: true,
            "Back": function(){
              return board.reloadBusinessMenu();
            }
          });
          return;
        }
      }
      if (that = field.calcPriceForHouses(menu.sliderNewVal, board.sliderFieldMap)) {
        price = that[0], board.sliderFieldMap = that[1];
      } else {
        player.buttons("Not possible!", {
          $noAnimation: true,
          "Back": function(){
            return board.reloadBusinessMenu();
          }
        });
        return;
      }
      if (price < 0) {
        btnText = "Receive: " + plural(-price, 'bit');
      } else {
        btnText = "Price: " + plural(price, 'bit');
      }
      player.buttons((ref$ = {
        $noAnimation: true
      }, ref$["Apply (" + btnText + ")"] = function(){
        var changeLog, i$, ref$, len$, otherField, newVal, oldVal, diff;
        changeLog = [];
        for (i$ = 0, len$ = (ref$ = board.fieldGroups[field.group]).length; i$ < len$; ++i$) {
          otherField = ref$[i$];
          newVal = board.sliderFieldMap[otherField.index];
          oldVal = Monopony.stringMaps.houses(otherField.houses);
          diff = newVal - oldVal;
          if (diff === 0) {} else if (oldVal === -1) {
            changeLog = changeLog.concat("repayed the mortgage for " + otherField.name);
          } else if (newVal === -1) {
            changeLog = changeLog.concat("mortgaged " + otherField.name);
          } else if (diff !== 0) {
            changeLog = changeLog.concat((diff > 0 ? 'up' : 'down') + "graded " + otherField.name + " to " + Monopony.stringMaps.houses(newVal));
          }
        }
        /*
        housesMap1 = {}
        housesMap2 = {}
        for houseType in Monopony.stringMaps.houses_
        	housesMap1[houseType] = 0
        	housesMap2[houseType] = 0
        
        for otherField in board.fieldGroups[field.group]
        	houseTypeCurrent = Monopony.stringMaps.houses otherField.houses
        	houseTypeNew = Monopony.stringMaps.houses board.sliderFieldMap[otherField.index]
        	housesMap1[houseTypeCurrent]++
        	housesMap2[houseTypeNew]++
        
        bs = {bought: [], sold: [], mortgaged: 0}
        for houseType, housesCurrent of housesMap1
        	housesNew = housesMap2[houseType]
        	diff = housesNew - housesCurrent
        	if housesNew == -1  &&  diff < 0
        		diff++
        		bs.mortgaged++
        	if houseType
        		if diff > 0
        			bs.bought ++= capitalize "#{plural diff, houseType}"
        		else if diff < 0
        			bs.sold ++= capitalize "#{plural diff, houseType}"
        
        housesStr = []
        if bs.bought.length
        	housesStr ++= "Bought #{list bs.bought}"
        if bs.sold.length
        	housesStr ++= "Sold #{list bs.sold}"
        if bs.mortgaged
        	housesStr ++= "Mortgaged #{plural bs.mortgaged, 'property', 'properties'}"
        */
        changeLog = list(changeLog) || "did nothing";
        if (price >= 0) {
          board.log(player.name + " " + changeLog + " for a total of " + plural(price, 'bit'));
        } else if (price < 0) {
          board.log(player.name + " " + changeLog + " and got " + plural(-price, 'bit'));
        }
        field.setHouses(menu.sliderNewVal, board.sliderFieldMap);
        return board.reBusinessMenu();
      }, ref$["Cancel"] = function(){
        return board.reloadBusinessMenu();
      }, ref$));
      for (fieldIndex in ref$ = board.sliderFieldMap) {
        houses = ref$[fieldIndex];
        x$ = board.businessMenus[fieldIndex];
        x$.sliderNewVal = houses;
        x$.update();
        results$.push(x$);
      }
      return results$;
    };
    return FieldMenu;
  }());
  Monopony.playerController = {
    /*
    "exampleBot":
    	buttons: (board, player, btns, callback) ->
    	roll_die: (board, player) ->
    	onChat: (board, player, from, to, message) -> # optional
    */
    "singleplayer": {
      buttons: function(board, btns, callback){
        return board.buttons(btns, callback);
      },
      msgBox: function(board, text, callback){
        return board.msgBox(text, callback);
      },
      input: function(board, type, btns, options){
        return board.input(type, btns, options);
      },
      rollDice: function(board, callback){
        return board.rollDice(callback);
      }
    },
    "local": {
      buttons: function(board, btns, callback){
        var btn, fn, btns2, i$, len$;
        board.reqNum++;
        console.log("[> buttons]", "(" + board.reqNum + ")", btns, callback, new Error().stack);
        if (board.multiplayerStack[board.reqNum]) {
          btn = board.multiplayerStack[board.reqNum];
          delete board.multiplayerStack[board.reqNum];
          return callback(board, btn);
        } else {
          board.multiplayerCallback = btns;
          fn = function(board, btn){
            return board.emit('button', board.reqNum, btn, board.currentPlayerNum);
          };
          btns2 = {};
          for (i$ = 0, len$ = btns.length; i$ < len$; ++i$) {
            btn = btns[i$];
            btns2[btn] = fn;
          }
          return board.buttons(btns2);
        }
      },
      msgBox: function(board, text, callback){
        return board.msgBox(text, callback);
      },
      rollDice: function(board){
        board.reqNum++;
        console.log("[> rollDice]", "(" + board.reqNum + ")", callback);
        board.multiplayerCallback = callback;
        if (board.multiplayerStack[board.reqNum]) {
          delete board.multiplayerStack[board.reqNum];
          return callback(board, board.multiplayerStack[board.reqNum]);
        } else if (board.room.isHost) {
          return board.emit('request_dice', board.reqNum);
        }
      }
    },
    "remote": {
      buttons: function(board, btns, callback){
        var btn;
        board.reqNum++;
        console.log("[> buttons]", "(" + board.reqNum + ")", btns);
        if (board.multiplayerStack[board.reqNum]) {
          btn = board.multiplayerStack[board.reqNum];
          delete board.multiplayerStack[board.reqNum];
          return callback(board, btn);
        } else {
          return board.multiplayerCallback = callback;
        }
      },
      msgBox: function(board, text, callback){
        throw Error('unimplemented');
        return callback(board);
      },
      rollDice: function(board, callback){
        var dice;
        board.reqNum++;
        console.log("[> rollDice]", "(" + board.reqNum + ")", callback);
        board.multiplayerCallback = callback;
        if (board.multiplayerStack[board.reqNum]) {
          dice = board.multiplayerStack[board.reqNum];
          delete board.multiplayerStack[board.reqNum];
          return callback(board, dice);
        } else if (board.room.isHost) {
          return board.emit('request_dice', board.reqNum);
        }
      }
    },
    "botSimple": {
      buttons: function(board, btns, callback){
        return callback(board, 0);
      },
      msgBox: function(board, text, callback){
        return callback(board);
      },
      rollDice: function(board, callback){
        return callback(board);
      }
    }
  };
  Monopony.chanceCards = [
    {
      title: "Advance to Ponyville Station",
      text: "Take a trip to Ponyville Station.\n\nIf you pass Go collect 200 Bits.",
      image: "train1",
      callback: function(board, player){
        /*
        if player.position > 5
        	#board.log "#{player.name} passed GO bla bla" #ToDo
        	player.receiveBits 200bits
        */
        return player.moveTo(5);
      }
    }, {
      title: "Advance to Las Pegasus",
      text: "Advance to Las Pegasus.\n\nIf you pass Go collect 200 Bits.",
      image: "las-pegasus",
      callback: function(board, player){
        if (player.position > 11) {
          player.receiveBits(200);
        }
        return player.moveTo(11);
      }
    }, {
      title: "Building and Loan matures",
      text: "Your building and loan matures\n\ncollect 150 Bits.",
      image: "bits",
      bits: 150
    }, {
      title: "Advance to next Railroad",
      _amount: 2,
      text: "Advance token to the next railroad and pay owner twice the rental to which he is otherwise entitled.\n\nIf the railroad is UNOWNED, you may buy it from the bank.",
      image: "train2",
      callback: function(board, player){
        var i$, to$, l, i, field, stationRent;
        for (i$ = 1, to$ = l = board.fields.length; i$ <= to$; ++i$) {
          i = i$;
          field = board.fields[(player.position + i) % l];
          if (field.station) {
            if (field.owner && field.owner !== player) {
              stationRent = field.calcRent();
              stationRent *= 2;
              player.moveTo(field.index, fn$);
            } else {
              player.moveTo(field.index);
            }
            return;
          }
        }
        board.log("[ERROR] next railroad not found :C");
        return board.endTurn();
        function fn$(){
          board.log(player.name + " has to pay " + field.owner.name + " " + plural(stationRent, 'bit'));
          return board.buttons("Pay", function(){
            board.log("*" + player.name + " pays " + field.owner.name + "*");
            return player.giveBitsTo(field.owner, stationRent, function(){
              return board.endTurn();
            });
          });
        }
      }
    }, {
      title: "Go back 3 spaces",
      text: "Go back 3 spaces.",
      image: "celestia1",
      callback: function(board, player){
        return player.move(-3);
      }
    }, {
      title: "Poor Tax",
      text: "Pay Poor Tax of 15 bits.",
      image: "bits",
      bits: -15
    }, {
      title: "Return from the Moon",
      _amount: 3,
      text: "Return from the Moon free.\n\nThis card may be kept until needed or traded/sold.",
      image: "theMoon",
      returnFromTheMoon: true
    }, {
      title: "Canterlot Bank dividend",
      text: "Canterlot pays you dividend of 50 Bits.",
      image: "bits",
      bits: 50
    }, {
      title: "Advance to next Utility",
      text: "Advance token to the nearest utility. If unowned you may buy it from the bank.\n\nIf owned, throw dice and pay owner a total ten \u00D7 the amount thrown.",
      image: "wonderbolts",
      callback: function(board, player){
        var i$, to$, l, i, field;
        for (i$ = 1, to$ = l = board.fields.length; i$ <= to$; ++i$) {
          i = i$;
          field = board.fields[(player.position + i) % l];
          if (field.utility) {
            player.move(field.index - player.position, fn$);
            return;
          }
        }
        board.log("[ERROR] next utility field not found :C");
        return board.endTurn();
        function fn$(){
          if (field.owner === null) {
            return player.processField();
          } else if (field.owner !== player) {
            return player.buttons({
              "Throw dice": function(){
                return player.rollDice(function(board, die){
                  var amount, ref$;
                  amount = die[0] * 10;
                  board.log(player.name + " threw a " + die[0] + ".");
                  board.log(player.name + " has to pay '" + field.owner.name + "' " + plural(amount, 'bit') + ".");
                  return player.buttons((ref$ = {}, ref$["Pay " + plural(amount, 'bit')] = function(){
                    return player.giveBitsTo(field.owner, amount, function(){
                      return board.endTurn();
                    });
                  }, ref$));
                });
              }
            });
          } else {
            return board.endTurn();
          }
        }
      }
    }, {
      title: "Advance to Whitetail Wood",
      text: "Advance to Whitetail Wood.\n\nIf you pass Go collect 200 Bits.",
      image: "whitetail-wood",
      callback: function(board, player){
        if (player.position > 24) {
          player.receiveBits(200);
        }
        return player.moveTo(24);
      }
    }, {
      title: "Mayor of Ponyville",
      text: "You have been elected mayor of Ponyville.\nPay each player 50 Bits.\n(note: you do NOT own the field 'Ponyville' now)",
      image: "mayor",
      callback: function(board, player){
        var amount;
        amount = (board.players.length - 1) * 50;
        if (player.bits < amount) {
          player.owes(amount);
          player.creditor(board.players.sans(player));
          return board.openBusinessMenu(function(){
            return board.endTurn();
          });
        } else {
          return icedCoffee(function(await){
            var i$, len$, results$ = [];
            for (i$ = 0, len$ = board.players.length; i$ < len$; ++i$) {
              results$.push((fn$.call(this, board.players[i$])));
            }
            return results$;
            function fn$(otherPlayer){
              if (otherPlayer !== player) {
                return await(function(defer){
                  return player.giveBitsTo(otherPlayer, 50, defer);
                });
              }
            }
          }, function(){
            return board.endTurn();
          });
        }
      }
    }, {
      title: "Advance to Canterlot",
      text: "Take a chariot to Canterlot.",
      image: "canterlot",
      callback: function(board, player){
        if (player.position > 39) {
          player.receiveBits(200);
        }
        return player.moveTo(39);
      }
    }, {
      title: "Advance to Go",
      text: "Advance to Go. Collect 200 Bits",
      image: "go",
      callback: function(board, player){
        return player.moveTo(0);
      }
    }, {
      title: "Repair costs",
      text: "Discord ravages Equestria.\nFor each house pay 25 bits,\nfor each hotel 100 bits.",
      image: "discord",
      callback: function(board, player){
        var costs, hotels, houses, i$, ref$, len$, field;
        costs = 0;
        hotels = 0;
        houses = 0;
        for (i$ = 0, len$ = (ref$ = board.fields).length; i$ < len$; ++i$) {
          field = ref$[i$];
          if (field.owner === player) {
            if (field.hotel) {
              hotels++;
            } else {
              houses++;
            }
          }
        }
        board.log(player.name + " owns " + plural(houses, 'house') + " and " + plural(hotels, 'hotel') + " and thus has to pay " + plural(hotels * 100 + houses * 25, 'bit'));
        player.pay(hotels * 100 + houses * 25);
        return board.endTurn();
      }
    }
  ];
  Monopony.communityChestCards = [
    {
      title: "Advance to Go",
      text: "Advance to Go (collect 200 bits)",
      image: "pinkie1",
      callback: function(board, player){
        return player.moveTo(0);
      }
    }, {
      title: "Bank error in your favor",
      text: "collect 200 bits",
      image: "derpy",
      bits: 200
    }, {
      title: "Hire DJ for party",
      text: "pay 50 bits",
      image: "vinyl",
      bits: -50
    }, {
      title: "Get released from Moon early",
      text: "This card may be kept until needed or sold",
      image: "nightmare-moon-shrug",
      returnFromTheMoon: true
    }, {
      title: "BANISHED!",
      text: "Go directly to the Moon\n\nDo NOT pass Go\nDo NOT collect 200 bits",
      image: "celestia2",
      callback: function(board, player){
        return player.toTheMoon();
      }
    }, {
      title: "It's your birthday",
      text: "Collect 10 bits from each player",
      image: "pinkie2",
      callback: function(board, player){
        return icedCoffee(function(await){
          var i$, len$, results$ = [];
          for (i$ = 0, len$ = board.players.length; i$ < len$; ++i$) {
            results$.push((fn$.call(this, board.players[i$])));
          }
          return results$;
          function fn$(otherPlayer){
            if (otherPlayer !== player) {
              return await(function(defer){
                return otherPlayer.giveBitsTo(player, 10, defer);
              });
            }
          }
        }, function(){
          return board.endTurn();
        });
      }
    }, {
      title: "Grand Galloping Gala",
      text: "Collect 50 bits from each player for ticket fees",
      image: "tickets",
      callback: function(board, player){
        return icedCoffee(function(await){
          var i$, len$, results$ = [];
          for (i$ = 0, len$ = board.players.length; i$ < len$; ++i$) {
            results$.push((fn$.call(this, board.players[i$])));
          }
          return results$;
          function fn$(otherPlayer){
            if (otherPlayer !== player) {
              return await(function(defer){
                return otherPlayer.giveBitsTo(player, 50, defer);
              });
            }
          }
        }, function(){
          return board.endTurn;
        });
      }
    }, {
      title: "Soarin buys a pie",
      text: "collect 20 bits",
      image: "soarin",
      bits: 20
    }, {
      title: "Life insurance matures",
      text: "Life insurance matures.\nCollect 100 bits",
      image: "old-pony",
      bits: 100
    }, {
      title: "Flying accident",
      text: "pay 100 bits for hospital fees",
      image: "rainbow-dash",
      bits: -100
    }, {
      title: "School fee",
      text: "Pay 50 bits",
      image: "cheerilee",
      bits: -50
    }, {
      title: "Parasprites invade",
      text: "Pay 40 bits per house\nand 115 bits per hotel",
      image: "parasprite",
      callback: function(board, player){
        var costs, hotels, houses, i$, ref$, len$, field;
        costs = 0;
        hotels = 0;
        houses = 0;
        for (i$ = 0, len$ = (ref$ = board.fields).length; i$ < len$; ++i$) {
          field = ref$[i$];
          if (field.owner === player) {
            if (field.hotel) {
              hotels++;
            } else {
              houses++;
            }
          }
        }
        board.log(player.name + " owns " + plural(houses, 'house') + " and " + plural(hotels, 'hotel') + " and thus has to pay " + plural(hotels * 115 + houses * 40, 'bit') + " repair costs");
        player.pay(hotels * 115 + houses * 40);
        return board.endTurn();
      }
    }, {
      title: "Win first price in a beauty contest",
      text: "Collect 100 bits",
      image: "rarity",
      bits: 100
    }, {
      title: "Win second price in a beauty contest",
      text: "Collect 10 bits",
      image: "twilight-sparkle2",
      bits: 10
    }, {
      title: "Sale of cider",
      text: "From sale of cider you receive 50 bits",
      image: "cider",
      bits: 50
    }, {
      title: "Organize wedding",
      text: "Collect 100 bits payment",
      image: "twilight-sparkle1",
      bits: 100
    }, {
      title: "Sell cherry to Fluttershy",
      text: "collect 25 bits",
      image: "cherry",
      bits: 25
    }
  ];
  for (i$ = 0, len$ = (ref$ = [Monopony['chanceCards'], Monopony['communityChestCards']]).length; i$ < len$; ++i$) {
    deck = ref$[i$];
    for (j$ = 0, len1$ = deck.length; j$ < len1$; ++j$) {
      card = deck[j$];
      for (k$ = 1, to$ = card._amount; k$ <= to$; ++k$) {
        deck.push(card);
      }
      delete card._amount;
    }
  }
  importAll$(Monopony, {
    generateID: function(){
      return (Math.random() * 0x100000000).toString(16);
    },
    getAvatarUrl: function(avatar){
      return "images/avatars/" + avatar.replace(/ /g, "_") + ".png";
    },
    defaultColors: ['maroon', 'red', 'pink', 'khaki', 'yellow', 'lightgreen', 'lime', 'cyan', 'blue', 'fuchsia'],
    defaultNames: ["Twilight", "Pinkie Pie", "Applejack", "Rainbow Dash", "Rarity", "Fluttershy", "Princess Luna", "Spike", "Gummy", "Derpy", "Colgate"]
    /*
    	* "Alptraum Mond"
    	* "Brinkie Pie"
    	* "Canpan"
    	* "Cookie"
    	* "Ryan"
    	* "Swift"
    	* "Thermal Cake"
    	* "TropicDash"
    */,
    customAvatars: ["Alptraum Mond", "Brinkie Pie", "Canpan", "Cookie", "Ryan", "Swift", "Thermal Cake", "TropicDash", "Death Mint", "MrSleepyguy"]
    /*
    	#- OCs - #ToDo: remove when out of beta
    	* "Brinkie Pie"
    	* "Thermal Cake"
    	* "Colgate"
    	* "Canpan"
    	* "Swift"
    	* "Alptraum Mond"
    	* "Ryan"
    	* "Cookie"
    	* "TropicDash"
    */,
    spaces: [
      {
        x: 816,
        y: 816
      }, {
        x: 710,
        y: 816
      }, {
        x: 638,
        y: 816
      }, {
        x: 566,
        y: 816
      }, {
        x: 494,
        y: 816
      }, {
        x: 422,
        y: 816
      }, {
        x: 350,
        y: 816
      }, {
        x: 278,
        y: 816
      }, {
        x: 206,
        y: 816
      }, {
        x: 134,
        y: 816
      }, {
        x: 30,
        y: 816
      }, {
        x: 30,
        y: 710
      }, {
        x: 30,
        y: 638
      }, {
        x: 30,
        y: 566
      }, {
        x: 30,
        y: 494
      }, {
        x: 30,
        y: 422
      }, {
        x: 30,
        y: 350
      }, {
        x: 30,
        y: 278
      }, {
        x: 30,
        y: 206
      }, {
        x: 30,
        y: 134
      }, {
        x: 30,
        y: 30
      }, {
        x: 134,
        y: 30
      }, {
        x: 206,
        y: 30
      }, {
        x: 278,
        y: 30
      }, {
        x: 350,
        y: 30
      }, {
        x: 422,
        y: 30
      }, {
        x: 494,
        y: 30
      }, {
        x: 566,
        y: 30
      }, {
        x: 638,
        y: 30
      }, {
        x: 710,
        y: 30
      }, {
        x: 816,
        y: 30
      }, {
        x: 816,
        y: 134
      }, {
        x: 816,
        y: 206
      }, {
        x: 816,
        y: 278
      }, {
        x: 816,
        y: 350
      }, {
        x: 816,
        y: 422
      }, {
        x: 816,
        y: 494
      }, {
        x: 816,
        y: 566
      }, {
        x: 816,
        y: 638
      }, {
        x: 816,
        y: 710
      }
    ],
    actions: {
      doNothing: function(board, player, field){
        return board.endTurn();
      }
      /*
      trainStation: (board, player, field) ->
      	board.log "#{player.name} stepped on the train station '#{field.name}'. #{player.name} may roll the die again."
      	board.startTurn!
      */,
      chance: function(board, player, field){
        board.log(player.name + " draws a chance card.");
        return player.drawCard('chance');
      },
      communityChest: function(board, player, field){
        board.log(player.name + " draws a card from the community chest.");
        return player.drawCard('communityChest');
      }
      /*
      parking: (board, player, field) ->
      	board.log "#{player.name} parks"
      	player.isParking = true
      	board.endTurn!
      */,
      visiteTheMoon: function(board, player, field){
        board.log(player + " is just visiting.");
        return board.endTurn();
      },
      toTheMoon: function(board, player, field){
        return player.toTheMoon();
      },
      incomeTax: function(board, player, field){
        var btnHasNotEnoughBits;
        board.log(player.name + " has to pay taxes! " + player.name + " can choose between paying 10% of all assets possessed OR 200 bits.");
        btnHasNotEnoughBits = player.bits < 200 ? "%" : "";
        return player.buttons({
          "Pay 10%": function(){
            var price;
            price = Math.ceil(player.getTotalAssets() * 0.1);
            board.log(player.name + " payed 10% off all assets. (" + plural(price, 'bit') + ")");
            player.pay(price);
            return board.endTurn();
          },
          "Pay 200 Bits": function(){
            var price;
            price = 200;
            board.log(player.name + " payed 200 bits.");
            player.pay(price);
            return board.endTurn();
          }
        });
      },
      luxuryTax: function(board, player, field){
        board.log(player.name + " has to pay 75 bits luruxy tax");
        return player.buttons("pay 75 bits luruxy tax", function(){
          board.log(player.name + " payed 75 bits.");
          player.pay(75);
          return board.endTurn();
        });
      }
    }
  });
  Monopony.prototype.fields = [
    new Monopony.ActionField({
      name: "GO",
      action: Monopony.actions.doNothing
    }), new Monopony.BuyableField({
      name: "Rock Farm",
      group: 0,
      price: 60,
      rent: 2,
      house1: 10,
      house2: 30,
      house3: 90,
      house4: 160,
      hotel: 250,
      housePrice: 50,
      mortgage: 30
    }), new Monopony.ActionField({
      name: "Community Chest",
      action: Monopony.actions.communityChest
    }), new Monopony.BuyableField({
      name: "Ponyville",
      group: 0,
      price: 80,
      rent: 4,
      house1: 20,
      house2: 60,
      house3: 180,
      house4: 320,
      hotel: 450,
      housePrice: 50,
      mortgage: 30
    }), new Monopony.ActionField({
      name: "Income Tax",
      action: Monopony.actions.incomeTax
    }), new Monopony.StationField({
      name: "Ponyville Station",
      price: 200,
      mortgage: 100
    }), new Monopony.BuyableField({
      name: "Fillydelphia",
      group: 1,
      price: 100,
      rent: 6,
      house1: 30,
      house2: 90,
      house3: 270,
      house4: 400,
      hotel: 550,
      housePrice: 50,
      mortgage: 50
    }), new Monopony.ActionField({
      name: "Chance",
      action: Monopony.actions.chance
    }), new Monopony.BuyableField({
      name: "Hoofington",
      group: 1,
      price: 100,
      rent: 6,
      house1: 30,
      house2: 90,
      house3: 270,
      house4: 400,
      hotel: 550,
      housePrice: 50,
      mortgage: 50
    }), new Monopony.BuyableField({
      name: "Trottingham",
      group: 1,
      price: 120,
      rent: 8,
      house1: 40,
      house2: 100,
      house3: 300,
      house4: 450,
      hotel: 600,
      housePrice: 50,
      mortgage: 60
    }), new Monopony.ActionField({
      name: "The Moon",
      action: Monopony.actions.doNothing
    }), new Monopony.BuyableField({
      name: "Las Pegasus",
      group: 2,
      price: 140,
      rent: 10,
      house1: 50,
      house2: 150,
      house3: 450,
      house4: 625,
      hotel: 750,
      housePrice: 100,
      mortgage: 70
    }), new Monopony.UtilityField({
      name: "Apple Harvest",
      price: 150
    }), new Monopony.BuyableField({
      name: "Baltimare",
      group: 2,
      price: 140,
      rent: 10,
      house1: 50,
      house2: 150,
      house3: 450,
      house4: 625,
      hotel: 750,
      housePrice: 100,
      mortgage: 70
    }), new Monopony.BuyableField({
      name: "Manehattan",
      group: 2,
      price: 160,
      rent: 12,
      house1: 60,
      house2: 180,
      house3: 500,
      house4: 700,
      hotel: 900,
      housePrice: 100,
      mortgage: 80
    }), new Monopony.StationField({
      name: "Appleloosa Station",
      price: 200,
      mortgage: 100
    }), new Monopony.BuyableField({
      name: "Appleloosa",
      group: 3,
      price: 180,
      rent: 14,
      house1: 70,
      house2: 200,
      house3: 550,
      house4: 750,
      hotel: 950,
      housePrice: 100,
      mortgage: 90
    }), new Monopony.ActionField({
      name: "Community Chest",
      action: Monopony.actions.communityChest
    }), new Monopony.BuyableField({
      name: "Dodge Junction",
      group: 3,
      price: 180,
      rent: 14,
      house1: 70,
      house2: 200,
      house3: 550,
      house4: 750,
      hotel: 950,
      housePrice: 100,
      mortgage: 90
    }), new Monopony.BuyableField({
      name: "Sweet Apple Acres",
      group: 3,
      price: 200,
      rent: 16,
      house1: 80,
      house2: 220,
      house3: 600,
      house4: 800,
      hotel: 1000,
      housePrice: 100,
      mortgage: 100
    }), new Monopony.ActionField({
      name: "Free Parking",
      action: Monopony.actions.doNothing
    }), new Monopony.BuyableField({
      name: "Canterlot Gardens",
      group: 4,
      price: 220,
      rent: 18,
      house1: 90,
      house2: 250,
      house3: 700,
      house4: 875,
      hotel: 1050,
      housePrice: 150,
      mortgage: 110
    }), new Monopony.ActionField({
      name: "Chance",
      action: Monopony.actions.chance
    }), new Monopony.BuyableField({
      name: "Ghastly Gorge",
      group: 4,
      price: 220,
      rent: 18,
      house1: 90,
      house2: 250,
      house3: 700,
      house4: 875,
      hotel: 1050,
      housePrice: 150,
      mortgage: 110
    }), new Monopony.BuyableField({
      name: "Whitetail Wood",
      group: 4,
      price: 240,
      rent: 20,
      house1: 100,
      house2: 300,
      house3: 750,
      house4: 925,
      hotel: 1100,
      housePrice: 150,
      mortgage: 120
    }), new Monopony.StationField({
      name: "Dodge Junction Station",
      price: 200,
      mortgage: 100
    }), new Monopony.BuyableField({
      name: "The Everfree Forest",
      group: 5,
      price: 260,
      rent: 22,
      house1: 110,
      house2: 330,
      house3: 800,
      house4: 975,
      hotel: 1150,
      housePrice: 150,
      mortgage: 130
    }), new Monopony.BuyableField({
      name: "Froggy Bottom Bog",
      group: 5,
      price: 260,
      rent: 22,
      house1: 110,
      house2: 330,
      house3: 800,
      house4: 975,
      hotel: 1150,
      housePrice: 150,
      mortgage: 130
    }), new Monopony.UtilityField({
      name: "Weather Factory",
      price: 150
    }), new Monopony.BuyableField({
      name: "Zecora's Hut",
      group: 5,
      price: 280,
      rent: 24,
      house1: 120,
      house2: 360,
      house3: 850,
      house4: 1025,
      hotel: 1200,
      housePrice: 150,
      mortgage: 140
    }), new Monopony.ActionField({
      name: "Banished To The Moon",
      action: Monopony.actions.toTheMoon
    }), new Monopony.BuyableField({
      name: "Sugarcube Corner",
      group: 6,
      price: 300,
      rent: 26,
      house1: 130,
      house2: 390,
      house3: 900,
      house4: 1100,
      hotel: 1275,
      housePrice: 200,
      mortgage: 150
    }), new Monopony.BuyableField({
      name: "Carousel Boutique",
      group: 6,
      price: 300,
      rent: 26,
      house1: 130,
      house2: 390,
      house3: 900,
      house4: 1100,
      hotel: 1275,
      housePrice: 200,
      mortgage: 150
    }), new Monopony.ActionField({
      name: "Community Chest",
      action: Monopony.actions.communityChest
    }), new Monopony.BuyableField({
      name: "School House",
      group: 6,
      price: 320,
      rent: 28,
      house1: 150,
      house2: 450,
      house3: 1000,
      house4: 1200,
      hotel: 1400,
      housePrice: 200,
      mortgage: 160
    }), new Monopony.StationField({
      name: "Canterlot Station",
      price: 200,
      mortgage: 100
    }), new Monopony.ActionField({
      name: "Chance",
      action: Monopony.actions.chance
    }), new Monopony.BuyableField({
      name: "Cloudsdale",
      group: 7,
      price: 350,
      rent: 35,
      house1: 175,
      house2: 500,
      house3: 1100,
      house4: 1300,
      hotel: 1500,
      housePrice: 200,
      mortgage: 175
    }), new Monopony.ActionField({
      name: "Luxury Tax",
      action: Monopony.actions.luxuryTax
    }), new Monopony.BuyableField({
      name: "Canterlot",
      group: 7,
      price: 400,
      rent: 50,
      house1: 200,
      house2: 600,
      house3: 1400,
      house4: 1700,
      hotel: 2000,
      housePrice: 200,
      mortgage: 200
    })
  ];
  for (i$ = 0, len$ = (ref$ = Monopony.prototype.fields).length; i$ < len$; ++i$) {
    i = i$;
    field = ref$[i$];
    field.index = i;
    if ('group' in field) {
      ((ref1$ = Monopony.prototype.fieldGroups)[key$ = field.group] || (ref1$[key$] = [])).push(field);
    }
  }
  Monopony.stringMaps = {
    houses_: [""].concat(['house', 'house', 'house', 'house', 'hotel']),
    houses: function(num){
      return this.houses_[num] || "ERROR";
    },
    housesShort_: importAll$(['X', '1', '2', '3', '4', 'H'], (ref$ = {}, ref$[-1] = "m", ref$[0] = "", ref$)),
    housesShort: function(num){
      return this.housesShort_[num] || "?";
    }
  };
  ref$ = Monopony.prototype;
  ref$.MP_SERVER = "/";
  ref$.initMultiplayer = function(){
    var board;
    board = this;
    if (!board.socket && board.multiplayerDeferred.state() === 'resolved') {
      return board.connect();
    }
    if (board.multiplayerDeferred.state() === 'pending') {
      board.multiplayer = true;
    }
    return board.multiplayerDeferred.promise();
  };
  ref$.reconnect = function(){
    var board;
    board = this;
    return board.multiplayerDeferred = $.getScript(board.MP_SERVER + "socket.io/socket.io.js").done(function(){
      board.boardDiv.addClass('serverOnline');
      if (board.multiplayer) {
        return board.connect();
      }
    });
  };
  ref$.connect = function(){
    var board, socket, i$, ref$, len$, player;
    board = this;
    socket = io.connect();
    board.socket = socket;
    board.multiplayer = true;
    board.boardDiv.addClass('multiplayer');
    for (i$ = 0, len$ = (ref$ = board.players).length; i$ < len$; ++i$) {
      player = ref$[i$];
      if (player.playerController === 'singleplayer') {
        player.playerController = 'local';
      }
    }
    board.reqs[0] = $.Deferred().then(function(userid){
      return board.players[0].id = board.id = userid;
    });
    socket.on('connect', function(){
      console.log("[< connect]", arguments);
      board.log("Connected to the Multiplayer Server");
      return board.emit('changeName', board.players[0].name);
    });
    socket.on('disconnect', function(){
      console.log("[< disconnect]", arguments);
      board.log("WARNING: The server disconnected. all rooms are closed");
      board.gotoLobby();
      return board.rooms = {};
    });
    socket.on('ok', function(reqID, data){
      var ref$, ref1$;
      console.log("[< ok]", reqID, data);
      board.reqs[reqID].resolve(data);
      return ref1$ = (ref$ = board.reqs)[reqID], delete ref$[reqID], ref1$;
    });
    socket.on('notOK', function(reqID, reason){
      var ref$, ref1$;
      console.log("[< notOK]", reqID, reason);
      board.reqs[reqID].reject(reason);
      return ref1$ = (ref$ = board.reqs)[reqID], delete ref$[reqID], ref1$;
    });
    socket.on('gameStarted', function(id){
      console.log("[< gameStarted]", id);
      if (id === board.room.id) {
        board.buttons();
        return board.startGame();
      }
    });
    socket.on('updateOptions', function(options){
      board.room.options = options;
      return board.applyOptions(options);
    });
    socket.on('dice', function(reqNum, dice1, dice2){
      console.log("[< dice]", "(" + reqNum + ")", dice1, dice2);
      if (board.reqNum === reqNum) {
        return board.multiplayerCallback(board, board.currentPlayer, [dice1, dice2]);
      } else {
        return board.multiplayerStack[reqNum] = [dice1, dice2];
      }
    });
    socket.on('button', function(reqNum, btn){
      console.log("[< button]", "(" + reqNum + ")", btn);
      if (board.reqNum === reqNum) {
        return board.multiplayerCallback[btn](board, board.currentPlayer, btn);
      } else {
        return board.multiplayerStack[reqNum] = btn;
      }
    });
    socket.on('buttonCheck', function(reqNum, btn, playerID){
      console.log("[< buttonCheck]", "(" + reqNum + ")", btn);
      if (board.currentPlayer.id === playerID) {
        return board.emit("button", reqNum, btn);
      } else {
        return board.log("WARNING: " + board.room.players[playerID].name + " tried to choose a button, but it's " + board.currentPlayer.name + "'s turn!");
      }
    });
    socket.on('lobby', function(roomList, userInLobby){
      console.log("[< lobby]", roomList, userInLobby);
      return board.rooms = roomList;
    });
    socket.on('roomCreated', function(id, roomName){
      console.log("[< roomCreated]", id, roomName);
      return board.rooms[id] = roomName;
    });
    socket.on('roomClosed', function(id){
      var ref$, ref1$;
      console.log("[< roomClosed]", id);
      if (board.room.id === id) {
        board.gotoLobby();
      }
      return ref1$ = (ref$ = board.rooms)[id], delete ref$[id], ref1$;
    });
    socket.on('playerLeftRoom', function(id, reason){
      console.log("[< playerLeftRoom]", id, reason);
      return board.removePlayer(board.room.players[id]);
    });
    socket.on('playerJoinedRoom', function(data){
      console.log("[< playerJoinedRoom]", data);
      board.log(data.name + " joined the room");
      return board.room.players[data.id] = board.addPlayer(data);
    });
    socket.on('kicked', function(reason){
      console.log("[< kicked]", reason);
      if (reason) {
        reason = " (" + reason + ")";
      } else {
        reason = "";
      }
      board.log("YOU GOT KICKED" + reason);
      return board.gotoLobby();
    });
    socket.on('playerChangedName', function(id, newName){
      var player;
      player = board.room.players[id];
      console.log("[< playerChangedName]", id, newName, player);
      player.name = newName;
      return player.status.trigger("nameChanged", player);
    });
    socket.on('playerChangedAvatar', function(id, newAvatar){
      return console.log("[< playerChangedAvatar]", id, newAvatar);
    });
    socket.on('chat', function(fromID, msg){
      var i$, ref$, len$, player, ref1$, results$ = [];
      console.log("[< chat]", fromID, msg);
      board.log("[chat] " + fromID + ": " + msg);
      for (i$ = 0, len$ = (ref$ = board.players).length; i$ < len$; ++i$) {
        player = ref$[i$];
        results$.push(typeof (ref1$ = Monopony.playerController[player.playerController]).onChat === 'function' ? ref1$.onChat(board, this, message) : void 8);
      }
      return results$;
    });
    return board.multiplayerDeferred;
  };
  ref$.emit = function(type){
    var args, board, reqID;
    args = slice$.call(arguments, 1);
    board = this;
    if (type === 'joinRoom' || type === 'createRoom') {
      reqID = Monopony.generateID();
      console.log("[> emit*]", reqID, type, args);
      args = [type, reqID].concat(args);
      board.socket.emit.apply(board.socket, args);
      board.reqs[reqID] = $.Deferred();
      return board.reqs[reqID];
    } else {
      console.log("[> emit]", arguments);
      return board.socket.emit.apply(board.socket, arguments);
    }
  };
  ref$.gotoLobby = function(){
    var board, socket, i$, ref$, len$, player;
    board = this;
    socket = board.socket;
    board.emit('gotoLobby');
    if (board.room) {
      for (i$ = 0, len$ = (ref$ = board.players).length; i$ < len$; ++i$) {
        player = ref$[i$];
        if (player.playerController === 'remote') {
          board.removePlayer(player);
        } else {
          player.reset();
        }
      }
      /* This is for allowing multiple players on one client
      for player in board.players
      	board.removePlayer(player)
      */
    }
    return board.buttons({
      "Start new Room": function(){
        return board.createRoom();
      },
      "Join another Room": function(){
        var rooms, roomIDs, btns, id, name;
        rooms = clone$(board.rooms);
        roomIDs = [];
        btns = {};
        for (id in rooms) {
          name = rooms[id];
          btns[name] = fn$;
          roomIDs = roomIDs.concat(id);
        }
        btns.$always = function(board, btn, i){
          return board.joinRoom(roomIDs[i]);
        };
        /*rooms = {
        	always: -> board.joinRoom Object.keys(rooms)[btn]
        } <<<< board.rooms*/
        return board.buttons(btns);
        function fn$(){}
      }
    });
  };
  ref$.createRoom = function(){
    board.room = {
      name: board.players[0].name + "'s Room",
      players: {},
      isHost: true
    };
    board.room[board.id] = board.players[0];
    board.log("creating a room...");
    return board.emit('createRoom', {
      name: board.room.name,
      startBits: board.startBits
    }).then(function(roomID){
      board.room.id = roomID;
      board.log("The room " + board.room.name + " was created");
      return board.buttons({
        "Start Game": function(){
          return board.gotoLobby();
        },
        "Close Room": function(){
          return board.emit('startGame');
        }
      });
    });
  };
  ref$.joinRoom = function(roomID){
    return board.emit('joinRoom', roomID).then(function(options){
      var i$, ref$, len$, player;
      console.log("[joinRoom cb]", options, arguments);
      board.room = {
        id: roomID,
        name: board.rooms[roomID],
        players: {},
        isHost: false,
        options: options
      };
      board.log("You joined " + board.room.name + ".\nWaiting for other players...");
      board.startBits = options.startBits;
      for (i$ = 0, len$ = (ref$ = board.players).length; i$ < len$; ++i$) {
        player = ref$[i$];
        board.removePlayer(player, true);
      }
      for (i$ = 0, len$ = (ref$ = options.players).length; i$ < len$; ++i$) {
        player = ref$[i$];
        if (player.id === board.id) {
          player.playerController = 'local';
        }
        board.room.players[player.id] = board.addPlayer(player);
      }
      board.applyOptions(options);
      return board.buttons({
        "Leave the Room": function(){
          return board.gotoLobby();
        }
      });
    });
  };
  $(function(){
    window.board = board = new Monopony($('#game'));
    return board.startMenu();
  });
  $(function(){
    var clickBtnQue, clickBtnListenerAttached;
    player = board.players[0];
    board.rollDice_ = board.rollDice;
    forceDice = function(num1, num2){
      if (board.multiplayer) {
        console.warn("[warning] using this in multiplayer is likely to break the game!");
      }
      if (num1 && num2 == null) {
        if (7 < num1 && num1 < 13) {
          num2 = num1 - 6;
          num1 = 6;
        } else {
          num1 = num1 - 1;
          num2 = 1;
        }
      }
      num1 = Math.floor(num1);
      num2 = Math.floor(num2);
      if (!((1 <= num1 && num1 <= 6) || (1 <= num2 && num2 <= 6))) {
        console.warn("[warning]", "One or both of the die have unusual values (1-6 is considered 'usual'). This is generally no problem but don't rely on it!");
      }
      if (num1 + num2 > 80) {
        console.warn("[warning]", "You forced die with a sum >40! This WILL crash the game!");
      } else if (num1 + num2 > 40) {
        console.warn("[warning]", "You forced die with a sum >40! This might crash the game!");
      }
      console.log("> going to roll a " + number(num1) + " and a " + number(num2) + " next time");
      if (num1 === num2) {
        console.log("> NOTE: those are doubles, so the player might roll the dice again");
      }
      board.rollDice = function(callback){
        var dice;
        console.log("[forced die]", num1, num2);
        board.rollDice = board.rollDice_;
        dice = [num1, num2];
        dice.sum = num1 + num2;
        return callback(board, dice);
      };
    };
    forceCard = function(cardName, cardNum){
      var decks, i$, len$, deck, j$, ref$, len1$, i, card, re, matches, ref1$, matchesInDeck, results$ = [];
      decks = ['chance', 'communityChest'];
      for (i$ = 0, len$ = decks.length; i$ < len$; ++i$) {
        deck = decks[i$];
        for (j$ = 0, len1$ = (ref$ = Monopony[deck + "Cards"]).length; j$ < len1$; ++j$) {
          i = j$;
          card = ref$[j$];
          if (card.title === cardName) {
            console.log("[forceCard] got it. (deck: " + deck + "Cards)");
            board[deck + "Cards"].unshift(card);
            return card;
          }
        }
      }
      console.warn("\t>The specified card could not be found, trying in-text-search");
      re = RegExp(cardName, 'i');
      matches = {};
      for (i$ = 0, len$ = decks.length; i$ < len$; ++i$) {
        deck = decks[i$];
        for (j$ = 0, len1$ = (ref$ = Monopony[deck + "Cards"]).length; j$ < len1$; ++j$) {
          card = ref$[j$];
          if (re.test(card.title) && not$(in$(card.title, matches))) {
            if (matches.length + 1 === cardNum) {
              console.log("[forceCard] got it. (deck: " + deck + "Cards)");
              board[deck + "Cards"].unshift(card);
            } else {
              (ref1$ = matches[deck] || (matches[deck] = []))[ref1$.length] = card;
            }
          }
        }
      }
      window.m = clone$(matches);
      if (!matches.isEmptyObject()) {
        for (deck in matches) {
          matchesInDeck = matches[deck];
          for (i$ = 0, len$ = matchesInDeck.length; i$ < len$; ++i$) {
            i = i$;
            card = matchesInDeck[i$];
            console.log("> possible match in " + deck + " #" + (1 + i) + ": " + card.title);
          }
          if (cardNum == null) {
            console.log("[forceCard] forcing '" + card.title + "' (deck: " + deck + "Cards)");
            results$.push(board[deck + "Cards"].unshift(card));
          }
        }
        return results$;
      } else {
        throw new Error("Sorry, the specified card could not be found");
      }
    };
    clickBtnQue = [];
    clickBtnListenerAttached = false;
    clickBtn = function(i, force){
      var btns, clickBtnListenerAttached;
      i == null && (i = 0);
      btns = board.buttonsField.find('button');
      if (btns.length && (force || !clickBtnQue.length)) {
        btns.eq(i).click();
      } else if (i != null) {
        clickBtnQue = clickBtnQue.concat(i);
      }
      if (clickBtnQue.length && !clickBtnListenerAttached) {
        clickBtnListenerAttached = true;
        return board.once('buttons', function(){
          var clickBtnListenerAttached;
          console.log("[BTNS]", clickBtnQue);
          clickBtnListenerAttached = false;
          return clickBtn(clickBtnQue.shift(), true);
        });
      }
    };
    checkUnusedPrototypeAttrs = function(){
      var i$, ref$, len$, i, attr, results$ = [];
      for (i$ = 0, len$ = (ref$ = board).length; i$ < len$; ++i$) {
        i = i$;
        attr = ref$[i$];
        if (typeof attr !== 'function' && deepEq$(attr, Monopony.prototype[i], '===')) {
          results$.push(console.warn(i, attr));
        } else if (not$(in$(i, Monopony.prototype))) {
          results$.push(console.error(i));
        }
      }
      return results$;
    };
    return showAllCards = function(){
      var i$, ref$, len$, $card, card, cardTitle, cardImage, cardText, results$ = [];
      for (i$ = 0, len$ = (ref$ = Monopony.chanceCards.concat(Monopony.communityChestCards)).length; i$ < len$; ++i$) {
        $card = ref$[i$];
        card = board.card.clone();
        cardTitle = card.find('.card-title');
        cardImage = card.find('.card-image');
        cardText = card.find('.card-text');
        cardTitle.text($card.title);
        cardImage.attr('src', "images/cards/" + $card.image + ".png");
        cardText.text($card.text);
        results$.push(card.appendTo('body'));
      }
      return results$;
    };
  });
  return (function(it){
    return it();
  })(function(){
    /*
    hasNoBtns = false
    setInterval do
    	->
    		if board.boardDiv.find \button .filter ($ it .visible!) .length == 0
    			sleep 5_000ms, ->
    				board.buttons "did the game crash?", do
    					"Yes": ->
    						board.msgBox "I'm sorry =(\nplease let me know about this and how it happened."
    						<- board.buttons "Restart game"
    						board.cleanUp!
    						board.startMenu!
    					"No": ->
    						board.msgBox "nvm =)\nkthxbye"
    	, 5_000ms
    	*/
    return window.debug = {
      title: "debug (GameOver)",
      fn: function(){
        board.addPlayer();
        board.addPlayer();
        board.startGame();
        board.fields[39].buy(board.players[1]);
        board.players[1].bits = 1;
        forceDice(1);
        clickBtn(0);
        clickBtn(0);
        clickBtn(0);
        console.warn("[TEST1]", {
          a: importAll$([], board._events.buttons)
        });
        return board.once('nextTurn', function(){
          forceDice(4);
          clickBtn(0);
          return console.warn("[TEST2]", {
            a: importAll$([], board._events.buttons)
          });
        });
      }
    };
  });
});
function importAll$(obj, src){
  for (var key in src) obj[key] = src[key];
  return obj;
}
function clone$(it){
  function fun(){} fun.prototype = it;
  return new fun;
}
function repeatString$(str, n){
  for (var r = ''; n > 0; (n >>= 1) && (str += str)) if (n & 1) r += str;
  return r;
}
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
function in$(x, xs){
  var i = -1, l = xs.length >>> 0;
  while (++i < l) if (x === xs[i]) return true;
  return false;
}
function not$(x){ return !x; }
function extend$(sub, sup){
  function fun(){} fun.prototype = (sub.superclass = sup).prototype;
  (sub.prototype = new fun).constructor = sub;
  if (typeof sup.extended == 'function') sup.extended(sub);
  return sub;
}
function deepEq$(x, y, type){
  var toString = {}.toString, hasOwnProperty = {}.hasOwnProperty,
      has = function (obj, key) { return hasOwnProperty.call(obj, key); };
  var first = true;
  return eq(x, y, []);
  function eq(a, b, stack) {
    var className, length, size, result, alength, blength, r, key, ref, sizeB;
    if (a == null || b == null) { return a === b; }
    if (a.__placeholder__ || b.__placeholder__) { return true; }
    if (a === b) { return a !== 0 || 1 / a == 1 / b; }
    className = toString.call(a);
    if (toString.call(b) != className) { return false; }
    switch (className) {
      case '[object String]': return a == String(b);
      case '[object Number]':
        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
      case '[object Date]':
      case '[object Boolean]':
        return +a == +b;
      case '[object RegExp]':
        return a.source == b.source &&
               a.global == b.global &&
               a.multiline == b.multiline &&
               a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object') { return false; }
    length = stack.length;
    while (length--) { if (stack[length] == a) { return true; } }
    stack.push(a);
    size = 0;
    result = true;
    if (className == '[object Array]') {
      alength = a.length;
      blength = b.length;
      if (first) { 
        switch (type) {
        case '===': result = alength === blength; break;
        case '<==': result = alength <= blength; break;
        case '<<=': result = alength < blength; break;
        }
        size = alength;
        first = false;
      } else {
        result = alength === blength;
        size = alength;
      }
      if (result) {
        while (size--) {
          if (!(result = size in a == size in b && eq(a[size], b[size], stack))){ break; }
        }
      }
    } else {
      if ('constructor' in a != 'constructor' in b || a.constructor != b.constructor) {
        return false;
      }
      for (key in a) {
        if (has(a, key)) {
          size++;
          if (!(result = has(b, key) && eq(a[key], b[key], stack))) { break; }
        }
      }
      if (result) {
        sizeB = 0;
        for (key in b) {
          if (has(b, key)) { ++sizeB; }
        }
        if (first) {
          if (type === '<<=') {
            result = size < sizeB;
          } else if (type === '<==') {
            result = size <= sizeB
          } else {
            result = size === sizeB;
          }
        } else {
          first = false;
          result = size === sizeB;
        }
      }
    }
    stack.pop();
    return result;
  }
}