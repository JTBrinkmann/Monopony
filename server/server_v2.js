// Generated by LiveScript 1.2.0
var PORT, IP, ONLY_LOCAL, BASEDIR, CACHE, TITLE, MAX_USER_PER_IP, SPAM_THRESHOLD, SPAM_LIMIT, SPAM_FORGIVE, SPAM_BAN_TIME, http, app, socket, fs, io, clone$, define, generateID, sleep, geoip, listPlayers, listRooms, status, ban, kick, fields, Monopony, players, lobby, rooms, SP, banlist, IPs, mime, urlToPath, loadGeoIp, slice$ = [].slice;
PORT = 80;
IP = 'unknown';
ONLY_LOCAL = false;
BASEDIR = __dirname + "/..";
CACHE = {
  image: 86400
};
TITLE = "Monopony Server";
MAX_USER_PER_IP = 32;
SPAM_THRESHOLD = 200;
SPAM_LIMIT = 10;
SPAM_FORGIVE = 10;
SPAM_BAN_TIME = 10;
require('colors');
http = require('http');
app = http.createServer(handler);
socket = require('socket.io');
fs = require('fs');
io = socket.listen(app);
io.set('log level', 1);
/*
= Features =
* Spam protection (max 10 messages to the server per 200ms)
* protection against inproper messages (invalid argument types etc)
* max 32 users per IP address
* decentralized game hosting (the server only relays messages and doesn't calculate the game itself)
	-> validity checks are to be done by the clients
* simple moderation system

*/
clone$ = function(it){
  return importAll$({}, it);
};
define = function(property, fn){
  if (this.hasOwnProperty(property)) {
    return console.warn("cannot redefine property", this, property, new TypeError().stack);
  } else if (this[property] !== fn) {
    return Object.defineProperty(this, property, {
      enumerable: false,
      writable: true,
      configurable: true,
      value: fn
    });
  }
};
define.call(Object.prototype, 'define', define);
Array.prototype.define('remove', function(it){
  var index;
  index = this.indexOf(it);
  if (index !== -1) {
    return this.splice(index, 1);
  }
});
generateID = function(namespace){
  var id;
  if (namespace) {
    id = generateID();
    while (id in namespace) {
      id = generateID();
    }
    return id;
  }
  return (Math.random() * 0x100000000).toString(16);
};
sleep = function(time, callback){
  return setTimeout(callback, time);
};
geoip = function(ip){
  var v4, data, sep, maxList, res$, i$, i, ref$, len$, block, list, j$, ridx$, len1$, k$, len2$;
  if (ip === '::1' || ip === '127.0.0.1') {
    return 'local';
  } else if (!global.geoip_data) {
    return '';
  }
  if (in$('.', ip)) {
    v4 = true;
    data = geoip_data.ipv4;
    sep = '.';
    maxList = [255, 254, 253, 252, 251, 250, 249, 248, 247, 246, 245, 244, 243, 242, 241, 240, 239, 238, 237, 236, 235, 234, 233, 232, 231, 230, 229, 228, 227, 226, 225, 224, 223, 222, 221, 220, 219, 218, 217, 216, 215, 214, 213, 212, 211, 210, 209, 208, 207, 206, 205, 204, 203, 202, 201, 200, 199, 198, 197, 196, 195, 194, 193, 192, 191, 190, 189, 188, 187, 186, 185, 184, 183, 182, 181, 180, 179, 178, 177, 176, 175, 174, 173, 172, 171, 170, 169, 168, 167, 166, 165, 164, 163, 162, 161, 160, 159, 158, 157, 156, 155, 154, 153, 152, 151, 150, 149, 148, 147, 146, 145, 144, 143, 142, 141, 140, 139, 138, 137, 136, 135, 134, 133, 132, 131, 130, 129, 128, 127, 126, 125, 124, 123, 122, 121, 120, 119, 118, 117, 116, 115, 114, 113, 112, 111, 110, 109, 108, 107, 106, 105, 104, 103, 102, 101, 100, 99, 98, 97, 96, 95, 94, 93, 92, 91, 90, 89, 88, 87, 86, 85, 84, 83, 82, 81, 80, 79, 78, 77, 76, 75, 74, 73, 72, 71, 70, 69, 68, 67, 66, 65, 64, 63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0];
  } else if (in$(':', ip)) {
    data = geoip_data.ipv4;
    sep = ':';
    res$ = [];
    for (i$ = 0xFFFF; i$ >= 0; --i$) {
      i = i$;
      res$.push(i.toString(16));
    }
    maxList = res$;
  } else {
    return false;
  }
  for (i$ = 0, len$ = (ref$ = ip.split(sep)).length; i$ < len$; ++i$) {
    block = ref$[i$];
    if (data[block]) {
      data = data[block];
    } else {
      if (v4) {
        res$ = [];
        for (j$ = block; j$ >= 0; --j$) {
          ridx$ = j$;
          res$.push(ridx$);
        }
        list = res$;
      } else {
        res$ = [];
        for (j$ = parseInt(block, 16); j$ >= 0; --j$) {
          i = j$;
          res$.push(i.toString(16));
        }
        list = res$;
      }
      for (j$ = 0, len1$ = list.length; j$ < len1$; ++j$) {
        i = list[j$];
        if (data[i]) {
          data = data[i];
          while (typeof data === 'object') {
            for (k$ = 0, len2$ = maxList.length; k$ < len2$; ++k$) {
              i = maxList[k$];
              if (data[i]) {
                data = data[i];
                break;
              }
            }
          }
          return data;
        }
      }
      return false;
    }
  }
  return data;
};
listPlayers = function(){
  var text, length, id, ref$, player;
  text = "";
  length = 0;
  for (id in ref$ = players) {
    player = ref$[id];
    length++;
    text += Monopony.player(player);
    if (player.position === 'LOBBY') {
      text += "\n  in " + 'The Lobby'.magenta.bold;
    } else {
      text += "\n  in room " + Monopony.room(player.position);
    }
    text += "\n  avatar: " + player.avatar + "\n\n";
  }
  if (length === 1) {
    text = ("[" + '1'.yellow + " player online]\n").bold + text;
  } else {
    text = ("[" + (length + '').yellow + " players online]\n").bold + text;
  }
  return text;
};
listRooms = function(){
  var text, i$, ref$, len$, yet$, player, length, id, room, ref1$;
  text = "= " + Monopony.room('LOBBY') + " =\n";
  for (yet$ = true, i$ = 0, len$ = (ref$ = lobby).length; i$ < len$; ++i$) {
    player = ref$[i$];
    yet$ = false;
    text += "\t" + Monopony.player(player) + "\n";
  } if (yet$) {
    text += "<empty>\n".grey;
  }
  text += "\n";
  length = 0;
  for (id in ref$ = rooms) {
    room = ref$[id];
    length++;
    text += "= " + Monopony.room(id) + " =\n";
    for (i$ = 0, len$ = (ref1$ = room.players).length; i$ < len$; ++i$) {
      player = ref1$[i$];
      text += "  " + Monopony.player(player) + "\n";
    }
    text += "\n";
  }
  if (length === 1) {
    text = ("[" + '1'.yellow + " room]\n").bold + text;
  } else {
    text = ("[" + (length + '').yellow + " rooms]\n").bold + text;
  }
  return text;
};
status = function(){
  var time;
  console.log("== STATUS ==".yellow.bold);
  console.log("IP: ".grey.bold, IP.magenta.bold + "" + ':'.bold + (PORT + '').magenta.bold);
  console.log("\n== Players ==".yellow.bold, listPlayers());
  console.log("== Rooms ==".yellow.bold, listRooms());
  console.log();
  console.log();
  time = Date.now();
  sleep(1, function(){
    var lag;
    lag = Date.now() - time;
    process.stdout.write("\x1b[2D\x1b[2A");
    switch (false) {
    case !(lag < 5):
      console.log("LAG: ".grey.bold, (lag + "ms").green.bold);
      break;
    case !(lag < 10):
      console.log("LAG: ".grey.bold, (lag + "ms").yellow.bold);
      break;
    default:
      console.log("LAG: ".grey.bold, (lag + "ms").red.bold);
    }
    console.log();
    process.stdout.write("\x1b[2C");
  });
};
ban = function(ipOrPlayer, reason){
  var player;
  if (player = Monopony.player(ipOrPlayer)) {
    Monopony.leaveRoom(player, reason || "banned by admin");
    player.disconnect('banned');
    banlist[player.ip] = true;
  } else if (typeof ipOrPlayer === 'string' && /\d\d\d?\.\d\d?\d?\.\d\d?\d?/.test(ipOrPlayer || /(\d{4}:){7}\d{4}/.test(ipOrPlayer))) {
    banlist[ipOrPlayer] = true;
  } else {
    console.log(("[!] couldn't ban player '" + ipOrPlayer + "' (not found)").redBG.yellow.bold);
  }
};
kick = function(player, reason){
  if (player = Monopony.player(player)) {
    Monopony.leaveRoom(player, reason || "kicked by admin");
    player.disconnect('kicked');
  } else {
    console.log(("[!] couldn't kick player '" + ipOrPlayer + "' (not found)").redBG.yellow.bold);
  }
};
fields = ["[A] GO", "[B] Rock Farm", "[A] Community Chest", "[B] Ponyville", "[A] Income Tax", "[S] Ponyville Station", "[B] Fillydelphia", "[A] Chance", "[B] Hoofington", "[B] Trottingham", "[A] The Moon", "[B] Las Pegasus", "[U] Apple Harvest", "[B] Baltimare", "[B] Manehattan", "[S] Appleloosa Station", "[B] Appleloosa", "[A] Community Chest", "[B] Dodge Junction", "[B] Sweet Apple Acres", "[A] Free Parking", "[B] Canterlot Gardens", "[A] Chance", "[B] Ghastly Gorge", "[B] Whitetail Wood", "[S] Dodge Junction Station", "[B] The Everfree Forest", "[B] Froggy Bottom Bog", "[U] Weather Factory", "[B] Zecora's Hut", "[A] Banished To The Moon", "[B] Sugarcube Corner", "[B] Carousel Boutique", "[A] Community Chest", "[B] School House", "[S] Canterlot Station", "[A] Chance", "[B] Cloudsdale", "[A] Luxury Tax", "[B] Canterlot"];
Monopony = {
  room: function(idOrRoom){
    if (!idOrRoom) {
      return false;
    } else if (idOrRoom === 'LOBBY') {
      return 'LOBBY'.magenta.bold;
    } else if (typeof idOrRoom === 'string') {
      idOrRoom = rooms[idOrRoom];
    }
    if (idOrRoom && typeof idOrRoom === 'object' && 'name' in idOrRoom && 'id' in idOrRoom) {
      return idOrRoom.id.magenta + " (" + idOrRoom.name.magenta.bold + ")";
    }
    return false;
  },
  player: function(idOrPlayer){
    if (!idOrPlayer) {
      return false;
    }
    if (typeof idOrPlayer === 'string') {
      idOrPlayer = players[idOrPlayer];
    }
    if (typeof idOrPlayer === 'object' && 'name' in idOrPlayer && 'id' in idOrPlayer) {
      return idOrPlayer.id.cyan + " (" + idOrPlayer.name.cyan.bold + ")";
    }
    return false;
  },
  field: function(fieldID){
    return fields[fieldID];
  },
  beautifyParams: function(arr){
    var res, i$, len$, i, el;
    res = new Array(arr.length);
    for (i$ = 0, len$ = arr.length; i$ < len$; ++i$) {
      i = i$;
      el = arr[i$];
      res[i] = Monopony.player(el || Monopony.room(el || (typeof el === 'string' ? "\"" + el + "\"" : el)));
    }
    return res;
  },
  userData: function(socket){
    if (typeof socket === 'string') {
      socket = players[socket];
    }
    return {
      id: socket.id,
      name: socket.name,
      avatar: socket.avatar,
      playerController: 'remote'
    };
  },
  notifyAllInRoom: function(roomOrPlayer, type){
    var params, room, i$, ref$, len$, otherPlayer, results$ = [];
    params = slice$.call(arguments, 2);
    room = rooms[roomOrPlayer.position] || roomOrPlayer;
    console.log.apply(console, ["> notifyAllInRoom".grey.bold, Monopony.room(room), type].concat(Monopony.beautifyParams(params)));
    for (i$ = 0, len$ = (ref$ = room.players).length; i$ < len$; ++i$) {
      otherPlayer = ref$[i$];
      console.log("-->", Monopony.player(otherPlayer));
      results$.push(otherPlayer.emit.apply(otherPlayer, [type].concat(params)));
    }
    return results$;
  },
  notifyAllInRoomButSelf: function(player, type){
    var params, room, i$, ref$, len$, otherPlayer;
    params = slice$.call(arguments, 2);
    room = rooms[player.position] || player;
    console.log("> notifyAllInRoomButSelf".grey.bold, Monopony.room(room), Monopony.player(player), type, " : ");
    console.log.apply(console, Monopony.beautifyParams(params));
    if (!(room || players in room)) {
      console.log("[EROOR] $notifyAllInRoomButSelf with inproper room".bold.red, [].concat(arguments));
      return false;
    }
    for (i$ = 0, len$ = (ref$ = room.players).length; i$ < len$; ++i$) {
      otherPlayer = ref$[i$];
      if (player !== player) {
        console.log("-->", Monopony.player(otherPlayer));
        otherPlayer.emit.apply(otherPlayer, [type].concat(params));
      }
    }
  },
  notifyAllInLobby: function(type){
    var params, i$, ref$, len$, otherPlayer;
    params = slice$.call(arguments, 1);
    console.log.apply(console, ["> notifyAllInLobby".grey.bold, type].concat(Monopony.beautifyParams(params)));
    for (i$ = 0, len$ = (ref$ = lobby).length; i$ < len$; ++i$) {
      otherPlayer = ref$[i$];
      console.log("-->", Monopony.player(otherPlayer));
      otherPlayer.emit.apply(lobby[i], [type].concat(params));
    }
  },
  leaveRoom: function(player, reason){
    var room, i$, ref$, len$, otherPlayer;
    console.log("[leaveRoom]".grey.bold, Monopony.player(player), Monopony.room(player.position), reason);
    room = rooms[player.position];
    room.players.remove(player);
    Monopony.notifyAllInRoom(room, 'playerLeftRoom', player.id, reason);
    player.position = 'LOBBY';
    Monopony.gotoLobby(player);
    if (room.creator === player.id) {
      Monopony.notifyAllInLobby('roomClosed', room.id, "host: " + reason);
      Monopony.notifyAllInRoom(room, 'roomClosed', room.id, "host: " + reason);
      for (i$ = 0, len$ = (ref$ = room.players).length; i$ < len$; ++i$) {
        otherPlayer = ref$[i$];
        Monopony.leaveRoom(otherPlayer, "host left");
      }
      return delete rooms[room.id];
    }
  },
  gotoLobby: function(player){
    var oldPosition, roomList, res$, i, ref$, room, usersInLobby, i$, len$, user;
    oldPosition = player.position;
    if (player.position !== 'LOBBY' && player.position !== 'SP') {
      Monopony.leaveRoom(player, "left room");
      lobby.push(player);
    }
    res$ = {};
    for (i in ref$ = rooms) {
      room = ref$[i];
      res$[i] = room.name;
    }
    roomList = res$;
    res$ = [];
    for (i$ = 0, len$ = (ref$ = lobby).length; i$ < len$; ++i$) {
      user = ref$[i$];
      res$.push(Monopony.userData(user));
    }
    usersInLobby = res$;
    player.emit('lobby', roomList, usersInLobby);
    io.sockets['in']('lobby').emit('otherUserJoined', player.id, Monopony.userData(player, oldPosition));
    return player.join('lobby');
  },
  avatars: fs.readdirSync(BASEDIR + "/images/avatars/").map(function(it){
    return it.replace(/\..*?$/, '');
  }),
  checks: {
    String: function(it){
      return typeof it === 'string';
    },
    Number: function(it){
      return isFinite(it);
    },
    Array: function(it){
      return it instanceof Array;
    },
    Player: function(it){
      return typeof it === 'string';
    },
    Room: function(it){
      return typeof it === 'string';
    },
    avatar: function(avi){
      if (in$(avi, this.avatars) || /^https?:\/\//.test(avi)) {
        return true;
      }
    },
    fieldID: function(it){
      return (0 <= it && it < fields.length) && i % 1 === 0;
    },
    tradeSubject: function(it){
      return subject === 'returnFromTheMoonCard' || checks.fieldID(it);
    }
  },
  on: function(socket, event, expectedArgs, fn){
    return socket.on(event, function(){
      var o, i$, ref$, len$, i, type, parg, optional, e;
      try {
        o = 0;
        for (i$ = 0, len$ = (ref$ = expectedArgs).length; i$ < len$; ++i$) {
          i = i$;
          type = ref$[i$];
          parg = arguments[o];
          if (type[type.length - 1] === '?') {
            optional = true;
            type = type.substring(0, -1);
          } else {
            optional = false;
          }
          if ((!optional && parg != null) && !Monopony.checks[type](parg)) {
            console.log("[improper args!]".red.bold + ("event: " + event + "\n\texpected"), expectedArgs, "\n\tgot", slice$.call(arguments));
            return false;
          }
        }
        return fn.apply(this, arguments);
      } catch (e$) {
        e = e$;
        return console.log("[ERROR]".red.bold, "on event '".grey + event.yellow.bold + "'. arguments:".grey, slice$.call(arguments), "\n", e.stack.red);
      }
    });
  }
};
players = io.sockets.sockets;
lobby = [];
rooms = {};
SP = [];
banlist = {};
IPs = {};
/*
	room = do
		id: roomID,
		players: [Socket, Socket, ...],
		setup: false,
		creator: PLAYER-ID,

		options: ...


	player = socket = do
		ip: "AAAA.BB.CC.DD"
		spamCount: 0
		lastCommand: DATE
		name: "user-SOCKET.ID"
		avatar: ""
		position: \LOBBY OR \SP OR "<ROOM-ID>"
		# bits: 0

	= Notes =
	The game is completly hosted by the host. The server does NOT check for cheating or sanity.
	This is not a bug but by design
*/
io.sockets.on('connection', function(socket){
  var e;
  try {
    socket.ip = socket.handshake.address.address;
    IPs[socket.ip]++;
    if (socket.ip in banlist) {
      if (banlist[socket.ip] > Date.now()) {
        console.log('==banned Client connected ['.red.bold + "" + socket.id.cyan + " (" + socket.ip.yellow.bold + ")" + ']=='.red.bold);
        socket.emit('error', 'ip banned');
        socket.disconnect('unauthorized');
        return;
      } else {
        delete banlist[socket.ip];
      }
    }
    if (IPs[socket.ip] > MAX_USER_PER_IP) {
      console.log('==spamming Client connected ['.red.bold + "" + socket.id.cyan + " (" + socket.ip.yellow.bold + ")" + ']=='.red.bold);
      socket.emit('error', "too many connections from your IP (" + socket.ip + ")");
      socket.disconnect('unauthorized');
      return;
    }
    console.log("==Client connected [".cyan.bold + socket.id.cyan + "] (".cyan.bold + (socket.ip + " " + geoip(socket.ip)).yellow.bold + ")==".cyan.bold);
    global.socket = socket;
    global.id = socket.id;
    socket.on('disconnect', function(data){
      console.log('==Client disconnected ['.yellow.bold + "" + Monopony.player(socket.id) + " (" + socket.ip.yellow.bold + ")" + ']=='.yellow.bold);
      IPs[socket.ip]--;
      if (socket.position !== 'LOBBY' && socket.position !== 'SP') {
        Monopony.leaveRoom(socket, 'disconnected');
      }
      return lobby.remove(socket);
    });
    socket.on('anything', function(){
      var date, timediff, ref$, unbanTime;
      date = Date.now();
      timediff = socket.lastCommand - date;
      if (timediff < SPAM_THRESHOLD) {
        socket.spamCount++;
      } else if (socket.spamCount) {
        socket.spamCount = 0 > (ref$ = Math.ceil(socket.spamCount - timediff * SPAM_FORGIVE / 1000)) ? 0 : ref$;
      }
      if (socket.spamCount > SPAM_LIMIT) {
        unbanTime = date + SPAM_BAN_TIME * 1000;
        banlist[socket.ip] = unbanTime;
        return socket.disconnected('spam', SPAM_BAN_TIME, unbanTime);
      }
    });
    socket.position = 'LOBBY';
    socket.name = "user-" + socket.id;
    socket.avatar = "";
    socket.playerController = 'remote';
    Monopony.gotoLobby(socket);
    Monopony.on(socket, 'chat', ['String'], function(message){
      var room;
      console.log("< chat".bold.grey, Monopony.player(socket.id), message.grey);
      room = rooms[socket.position];
      return Monopony.notifyAllInRoomButSelf(socket, 'chat', socket.id, Date.now());
    });
    socket.on('changeName', function(newName){
      console.log("< changeName".bold.grey, Monopony.player(socket.id), "->", newName.cyan.bold);
      if (socket.position === 'LOBBY' || socket.position === 'SP') {
        return socket.name = newName;
      } else if (rooms[socket.position].setup) {
        socket.name = newName;
        return Monopony.notifyAllInRoomButSelf(socket, 'playerChangedName', socket.id, newName);
      }
    });
    socket.on('changeAvatar', function(newAvatar){
      console.log("< chanceAvatar".bold.grey, Monopony.player(socket.id), "-->", newAvatar);
      if (socket.position === 'LOBBY' || socket.position === 'SP') {
        return socket.avatar = newAvatar;
      } else if (rooms[socket.position].setup) {
        socket.avatar = newAvatar;
        return Monopony.notifyAllInRoomButSelf(socket, 'playerChangedAvatar', socket.id, newAvatar);
      }
    });
    socket.on('createRoom', function(reqID, options){
      var roomID;
      console.log("< createRoom".bold.grey, Monopony.player(socket.id), options.name, options);
      roomID = generateID(rooms);
      if (!options.name) {
        options.name = roomID;
      }
      rooms[roomID] = {
        id: roomID,
        name: options.name,
        setup: true,
        players: [socket],
        currentPlayer: null,
        creator: socket.id,
        options: {
          startBits: +options.startBits || 1500
        }
      };
      socket.position = roomID;
      lobby.remove(socket);
      Monopony.notifyAllInLobby('roomOpened', roomID, options.name);
      return socket.emit('ok', reqID, roomID);
    });
    socket.on('joinRoom', function(reqID, roomID){
      var room, players, res$, i$, ref$, len$, otherPlayer;
      console.log("< joinRoom".grey.bold, Monopony.player(socket.id), Monopony.room(roomID));
      if (!roomID) {
        console.warn("--> no roomID specified");
        return;
      }
      room = rooms[roomID];
      if (!room) {
        console.warn("--> no such room", roomID.red.bold);
        socket.emit('notOk', reqID, "room does not exist");
        return;
      }
      socket.position = roomID;
      lobby.remove(socket);
      room.players = room.players.concat(socket);
      Monopony.notifyAllInRoomButSelf(socket, 'playerJoinedRoom', Monopony.userData(socket));
      res$ = [];
      for (i$ = 0, len$ = (ref$ = room.players).length; i$ < len$; ++i$) {
        otherPlayer = ref$[i$];
        res$.push(Monopony.userData(otherPlayer.id));
      }
      players = res$;
      return socket.emit('ok', reqID, importAll$({
        players: players
      }, room.options));
    });
    socket.on('startGame', function(){
      var room;
      console.log("< startGame".bold.grey, Monopony.player(socket.id));
      room = rooms[socket.position];
      if (room.creator === socket.id) {
        room.setup = false;
        Monopony.notifyAllInRoom(socket, 'gameStarted', socket.position);
        return Monopony.notifyAllInLobby('gameStarted', socket.position);
      } else {
        return console.log("\tperson requesting is not the host".yellow.bold);
      }
    });
    socket.on('kick', function(playerID, reason){
      var room;
      console.log("< kick".red.bold, Monopony.player(socket.id), "-->", Monopony.player(playerID), "(" + reason + ")");
      room = rooms[socket.position];
      if (!players[playerID].position === room.id) {
        return socket.emit('chat', "[SYSTEM] there is no player with this ID in the room");
      }
      if (room.creator === socket.id) {
        players[playerID].emit('kicked', reason);
        if (reason) {
          reason = "kicked (" + reason + ")";
        } else {
          reason = "kicked";
        }
        return Monopony.leaveRoom(players[playerID], reason);
      } else {
        socket.emit('chat', "[SYSTEM] only the host can kick other players.");
        return console.log("\tperson requesting is not the host".yellow.bold);
      }
    });
    socket.on('ban', function(username, reason){
      console.log("< ban".bold.grey, username, reason);
      throw Error('unimplemented');
    });
    socket.on('joinLobby', function(){
      console.log("< joinLobby".bold.grey, Monopony.player(socket.id));
      return Monopony.gotoLobby(socket);
    });
    socket.on('button', function(btn){
      console.log("< button".bold.grey, Monopony.player(socket.id), "(" + reqNum + ")", btn);
      return Monopony.notifyAllInRoom(socket, 'button', socket.id, btn);
    });
    socket.on('request_dice', function(reqNum){
      console.log("[request_dice]".bold.grey, "(" + reqNum + ")", Monopony.player(socket.id));
      return Monopony.notifyAllInRoom(socket, 'dice', reqNum, Math.ceil(Math.random() * 6), Math.ceil(Math.random() * 6));
    });
    socket.on('setFieldHouses', function(fieldID, houses){
      console.log("< setFieldHouses".bold.grey, Monopony.player(socket.id), Monopony.field(fieldID), houses);
      return Monopony.notifyAllInRoom(socket, 'setFieldHouses', socket.id, btn);
    });
    socket.on('trade', function(sellingOrBuying, otherUserID, subject, priceOffer){
      console.log("< trade".bold.grey, Monopony.player(socket.id), sellingOrBuying, Monopony.player(otherUserID), subject, priceOffer);
      return players[otherUserID].emit('tradeOffer', socket.id, sellingOrBuying, otherUserID, subject, priceOffer);
    });
    socket.on('tradeAccept', function(otherUserID, subject){
      console.log("< tradeAccept".bold.grey, Monopony.player(socket.id), Monopony.player(otherUserID), subject);
      return players[otherUserID].emit('tradeAccept', socket.id, subject);
    });
    socket.on('tradeDeny', function(otherUserID, subject){
      console.log("< tradeDeny".bold.grey, Monopony.player(socket.id), Monopony.player(otherUserID), subject);
      return players[otherUserID].emit('tradeDeny', socket.id, subject);
    });
    /* socket.on \updateOptions, (options) ->
    	console.log "< updateOptions".grey.bold, options
    	room = rooms[socket.position]
    
    	if room.creator == socket.id
    		Monopony.notifyAllInRoom room, \updateOptions, options
    	else
    		socket.emit \chat, "[SYSTEM] only the host can change the options, ask him/her to do it."
    		console.log "\tperson requesting is not the host".yellow.bold
    */
    return socket.emit('welcome', socket.id);
  } catch (e$) {
    e = e$;
    console.error("[ERROR]".bold.red, ("on connecting to socket " + socket.id + " (" + socket.handshake.address.address + ")\n").bold.red, e.stack.red);
    return socket.emit('error');
  }
});
mime = require('mime');
urlToPath = function(url){
  return BASEDIR + url.replace(/\.\.\\/g, '').replace(/\/.*?\/\.\.\//g, '').replace(/(?:#|\?).*/, '').replace(/\/$/, '/index.html').replace(/%20/g, " ").replace(/(\/[^\.]*)$/, '$1.html');
};
function handler(req, res){
  var ip, paths, tryFile, e;
  try {
    ip = req.connection.remoteAddress;
    if (/(?:.\.html?|\/)$/i.test(req.url)) {
      console.log("==User connects==".cyan.bold, (ip + " " + geoip(ip)).yellow.bold);
    }
    console.log("< " + req.url.cyan);
    /*
    if req.url == "/GEOIP"
    	res.writeHead 200, 'Content-Type': "text/plain"
    	console.log "converting to JSON"
    	res.end JSON.stringify geoip_data
    	console.log "done"
    	return
    */
    paths = [urlToPath(req.url)];
    if (/\/index\.html$/.test(paths[0])) {
      paths = paths.concat(paths[0].replace(/\/index\.html$/, ".html"));
    } else if (!in$(".", paths[0].substr(BASEDIR.length))) {
      paths = paths.concat(paths[0] + "/index.html");
    }
    tryFile = function(path){
      return fs.readFile(path, function(err, data){
        var mimeType;
        if (err) {
          if (paths.length) {
            console.log("couldn't load: " + path.red.bold);
            console.log("retrying...");
            tryFile(paths.shift());
          } else {
            console.log("couldn't load: " + path.red.bold, ("[" + err.errno + "]").bold.red);
            if (err.errno === 34) {
              res.writeHead(404);
              res.end('file not found :(');
            } else {
              console.log("unknown error: ", err);
              res.writeHead(500);
              res.end('internal error D:');
            }
          }
        }
        mimeType = mime.lookup(path);
        console.log("> " + path.green + " [" + mimeType + "]");
        res.writeHead(200, {
          'Content-Type': mimeType,
          'Cache-Control': "max-age=" + (CACHE[req.url] || CACHE[path] || CACHE[mimeType] || CACHE[mimeType.replace(/\/.*/, "")] || 5)
        });
        return res.end(data);
      });
    };
    return tryFile(paths.shift());
  } catch (e$) {
    e = e$;
    console.error("[INTERNAL ERROR]".bold.red, err);
    res.writeHead(500);
    return res.end('internal error D:');
  }
}
(function(){
  var data, request;
  data = "";
  request = http.request({
    hostname: "jsonip.appspot.com",
    port: 80,
    path: '/',
    method: 'POST'
  }, function(response){
    response.on('data', function(chunk){
      return data += chunk;
    });
    response.on('end', function(chunk){
      data += chunk;
      IP = /(?:\d|\.)+/.exec(data)[0];
      console.log("server address: http://" + IP + ":" + PORT);
      console.log();
      return require("./CLI_debug.js");
    });
    return response.on('error', function(){
      console.log(('[Error]'.bold.red + " receiving IP. Maybe you are not connected to the internet?\n").bold.red);
      return require("./CLI_debug.js");
    });
  });
  request.on('error', function(e){
    console.log(('[Error]'.bold.red + " receiving IP. Maybe you are not connected to the internet?\n").bold.red);
    return require("./CLI_debug.js");
  });
  return request.end();
})();
/*
setInterval do
	->
		for from 100 to 0
			void
		time1 = Date.now!
		sleep 0ms, ->
			time2 = Date.now!
			process.title = "#{TITLE} (#{time2 - time1}ms lag)"
	,3000ms
*/
app.on('error', function(arg$){
  var errno;
  errno = arg$.errno;
  if (errno === 'EADDRINUSE') {
    PORT++;
    console.log(("\nretrying on port " + PORT).cyan);
    return app.listen(PORT);
  }
});
app.listen(PORT);
console.log(("\nrunning on port " + PORT).cyan);
console.log("use 'loadGeoIp()' to show IPs with their according country".yellow.bold);
loadGeoIp = function(){
  var geoip_data;
  console.log("loading GeoIP data...");
  geoip_data = require('./geoip_data.js');
};
importAll$(global, {
  PORT: PORT,
  IP: IP,
  ONLY_LOCAL: ONLY_LOCAL,
  BASEDIR: BASEDIR,
  CACHE: CACHE,
  TITLE: TITLE,
  MAX_USER_PER_IP: MAX_USER_PER_IP,
  SPAM_THRESHOLD: SPAM_THRESHOLD,
  SPAM_LIMIT: SPAM_LIMIT,
  SPAM_FORGIVE: SPAM_FORGIVE,
  SPAM_BAN_TIME: SPAM_BAN_TIME,
  http: http,
  app: app,
  socket: socket,
  fs: fs,
  io: io,
  define: define,
  generateID: generateID,
  sleep: sleep,
  geoip: geoip,
  listPlayers: listPlayers,
  listRooms: listRooms,
  status: status,
  ban: ban,
  kick: kick,
  fields: fields,
  Monopony: Monopony,
  players: players,
  lobby: lobby,
  rooms: rooms,
  SP: SP,
  banlist: banlist,
  IPs: IPs,
  mime: mime,
  urlToPath: urlToPath,
  loadGeoIp: loadGeoIp
});
function importAll$(obj, src){
  for (var key in src) obj[key] = src[key];
  return obj;
}
function in$(x, xs){
  var i = -1, l = xs.length >>> 0;
  while (++i < l) if (x === xs[i]) return true;
  return false;
}